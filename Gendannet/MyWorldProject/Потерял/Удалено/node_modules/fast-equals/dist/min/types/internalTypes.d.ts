/**
 * Cache used to store references to objects, used for circular
 * reference checks.
 */
export interface Cache<Key extends object, Value> {
    delete(key: Key): boolean;
    get(key: Key): Value | undefined;
    set(key: Key, value: any): any;
}
export interface State<Meta> {
    /**
     * Cache used to identify circular references
     */
    readonly cache: Cache<any, any> | undefined;
    /**
     * Method used to determine equality of nested value.
     */
    readonly equals: InternalEqualityComparator<Meta>;
    /**
     * Additional value that can be used for comparisons.
     */
    meta: Meta;
    /**
     * Whether the equality comparison is strict, meaning it matches
     * all properties (including symbols and non-enumerable properties)
     * with equal shape of descriptors.
     */
    readonly strict: boolean;
}
export interface CircularState<Meta> extends State<Meta> {
    readonly cache: Cache<any, any>;
}
export interface DefaultState<Meta> extends State<Meta> {
    readonly cache: undefined;
}
export interface Dictionary<Value = any> {
    [key: string | symbol]: Value;
    $$typeof?: any;
}
export interface ComparatorConfig<Meta> {
    /**
     * Whether the arrays passed are equal in value. In strict mode, this includes
     * additional properties added to the array.
     */
    areArraysEqual: TypeEqualityComparator<any, Meta>;
    /**
     * Whether the dates passed are equal in value.
     */
    areDatesEqual: TypeEqualityComparator<any, Meta>;
    /**
     * Whether the maps passed are equal in value. In strict mode, this includes
     * additional properties added to the map.
     */
    areMapsEqual: TypeEqualityComparator<any, Meta>;
    /**
     * Whether the objects passed are equal in value. In strict mode, this includes
     * non-enumerable properties added to the map, as well as symbol properties.
     */
    areObjectsEqual: TypeEqualityComparator<any, Meta>;
    /**
     * Whether the primitive wrappers passed are equal in value.
     */
    arePrimitiveWrappersEqual: TypeEqualityComparator<any, Meta>;
    /**
     * Whether the regexps passed are equal in value.
     */
    areRegExpsEqual: TypeEqualityComparator<any, Meta>;
    /**
     * Whether the sets passed are equal in value. In strict mode, this includes
     * additional properties added to the set.
     */
    areSetsEqual: TypeEqualityComparator<any, Meta>;
    /**
     * Whether the typed arrays passed are equal in value. In strict mode, this includes
     * additional properties added to the typed array.
     */
    areTypedArraysEqual: TypeEqualityComparator<any, Meta>;
}
export type CreateCustomComparatorConfig<Meta> = (config: ComparatorConfig<Meta>) => Partial<ComparatorConfig<Meta>>;
export type CreateState<Meta> = () => {
    cache?: Cache<any, any> | undefined;
    meta?: Meta;
};
export type EqualityComparator<Meta> = <A, B>(a: A, b: B, state: State<Meta>) => boolean;
export type AnyEqualityComparator<Meta> = (a: any, b: any, state: State<Meta>) => boolean;
export type EqualityComparatorCreator<Meta> = (fn: EqualityComparator<Meta>) => InternalEqualityComparator<Meta>;
export type InternalEqualityComparator<Meta> = (a: any, b: any, indexOrKeyA: any, indexOrKeyB: any, parentA: any, parentB: any, state: State<Meta>) => boolean;
export type PrimitiveWrapper = Boolean | Number | String;
/**
 * Type which encompasses possible instances of TypedArray
 * classes.
 *
 * **NOTE**: This does not include `BigInt64Array` and
 * `BitUint64Array` because those are part of ES2020 and
 * not supported by certain TS configurations. If using
 * either in `areTypedArraysEqual`, you can cast the
 * instance as `TypedArray` and it will work as expected,
 * because runtime checks will still work for those classes.
 */
export type TypedArray = Float32Array | Float64Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array | Uint8Array | Uint8ClampedArray;
export type TypeEqualityComparator<Type, Meta = undefined> = (a: Type, b: Type, state: State<Meta>) => boolean;
export interface CustomEqualCreatorOptions<Meta> 
54ed0bb2e99532907ef95232b25d7a5b7f15ce80	{"key":"make-fetch-happen:request-cache:https://registry.npmjs.org/@types%2fd3-time","integrity":"sha512-Rj6q9g8MT8X2QzyULoCYupsskEmtz46HOOhEUiQCoPSoE9g0tCh9j/zPZ2R0JCWB4tLWmWl4iltdjS3Ik2HPiQ==","time":1721493822654,"size":21558,"metadata":{"time":1721493822646,"url":"https://registry.npmjs.org/@types%2fd3-time","reqHeaders":{"accept":"application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"},"resHeaders":{"cache-control":"public, max-age=300","content-encoding":"gzip","content-type":"application/vnd.npm.install-v1+json","date":"Sat, 20 Jul 2024 16:43:43 GMT","etag":"W/\"c274791adf61a0a401c91d744031465c\"","last-modified":"Mon, 24 Jun 2024 09:37:39 GMT","vary":"accept-encoding, accept"},"options":{"compress":true}}}
5a950fc4521b4406951920f5eb2751e9cc365287	{"key":"make-fetch-happen:request-cache:https://registry.npmjs.org/@types%2fd3-time","integrity":"sha512-2ANyLQHlQnghchB7PzF73olWhjSJEH4XpA3QtIexwxduX3tQTJInYyWPZHi5BaDFCjKKrJ0UeKHow47lQAXHew==","time":1724973576455,"size":21574,"metadata":{"time":1724973576452,"url":"https://registry.npmjs.org/@types%2fd3-time","reqHeaders":{"accept":"application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"},"resHeaders":{"cache-control":"public, max-age=300","content-encoding":"gzip","content-type":"application/vnd.npm.install-v1+json","date":"Thu, 29 Aug 2024 23:19:36 GMT","etag":"W/\"205f0b