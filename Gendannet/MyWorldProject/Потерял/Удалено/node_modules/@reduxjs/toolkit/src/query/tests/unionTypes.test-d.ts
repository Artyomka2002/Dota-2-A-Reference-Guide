import type { SerializedError } from '@reduxjs/toolkit'
import type {
  FetchBaseQueryError,
  TypedUseMutationResult,
  TypedUseQueryHookResult,
  TypedUseQueryState,
  TypedUseQueryStateResult,
  TypedUseQuerySubscriptionResult,
  TypedLazyQueryTrigger,
  TypedUseLazyQuery,
  TypedUseLazyQuerySubscription,
  TypedUseMutation,
  TypedMutationTrigger,
  TypedUseQuerySubscription,
  TypedUseQuery,
} from '@reduxjs/toolkit/query/react'
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

const baseQuery = fetchBaseQuery()

const api = createApi({
  baseQuery,
  endpoints: (build) => ({
    getTest: build.query<string, void>({ query: () => '' }),
    mutation: build.mutation<string, void>({ query: () => '' }),
  }),
})

describe('union types', () => {
  test('query selector union', () => {
    const result = api.endpoints.getTest.select()({} as any)

    if (result.isUninitialized) {
      expectTypeOf(result.data).toBeUndefined()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()
    }

    if (result.isLoading) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError | undefined
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()
    }

    if (result.isError) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()
    }

    if (result.isSuccess) {
      expectTypeOf(result.data).toBeString()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()
    }

    expectTypeOf(result).not.toBeNever()

    // is always one of those four
    if (
      !result.isUninitialized &&
      !result.isLoading &&
      !result.isError &&
      !result.isSuccess
    ) {
      expectTypeOf(result).toBeNever()
    }
  })

  test('useQuery union', () => {
    const result = api.endpoints.getTest.useQuery()

    if (result.isUninitialized) {
      expectTypeOf(result.data).toBeUndefined()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toEqualTypeOf<false>()
    }

    if (result.isLoading) {
      expectTypeOf(result.data).toBeUndefined()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError | undefined
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toBeBoolean()
    }

    if (result.isError) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toEqualTypeOf<false>()
    }

    if (result.isSuccess) {
      expectTypeOf(result.data).toBeString()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toBeBoolean()
    }

    if (result.isFetching) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError | undefined
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toBeBoolean()

      expectTypeOf(result.isSuccess).toBeBoolean()

      expectTypeOf(result.isError).toEqualTypeOf<false>()
    }

    expectTypeOf(result.currentData).toEqualTypeOf<string | undefined>()

    if (result.isSuccess) {
      if (!result.isFetching) {
        expectTypeOf(result.currentData).toBeString()
      } else {
        expectTypeOf(result.currentData).toEqualTypeOf<string | undefined>()
      }
    }

    expectTypeOf(result).not.toBeNever()

    // is always one of those four
    if (
      !result.isUninitialized &&
      !result.isLoading &&
      !result.isError &&
      !result.isSuccess
    ) {
      expectTypeOf(result).toBeNever()
    }
  })
  test('useQuery TS4.1 union', () => {
    const result = api.useGetTestQuery()

    if (result.isUninitialized) {
      expectTypeOf(result.data).toBeUndefined()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toEqualTypeOf<false>()
    }

    if (result.isLoading) {
      expectTypeOf(result.data).toBeUndefined()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError | undefined
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toBeBoolean()
    }

    if (result.isError) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toEqualTypeOf<false>()
    }

    if (result.isSuccess) {
      expectTypeOf(result.data).toBeString()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isFetching).toBeBoolean()
    }

    if (result.isFetching) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError | undefined
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toBeBoolean()

      expectTypeOf(result.isSuccess).toBeBoolean()

      expectTypeOf(result.isError).toEqualTypeOf<false>()
    }

    expectTypeOf(result).not.toBeNever()

    // is always one of those four
    if (
      !result.isUninitialized &&
      !result.isLoading &&
      !result.isError &&
      !result.isSuccess
    ) {
      expectTypeOf(result).toBeNever()
    }
  })

  test('useLazyQuery union', () => {
    const [_trigger, result] = api.endpoints.getTest.useLazyQuery()

    if (result.isUninitialized) {
      expectTyp‰PNG

   IHDR   <   <   :üÙr   	pHYs       O%ÄÖ   $zTXtCreator  ™sLÉOJUpL+I-RpMKKM.) AzÎjzÅ  ¹IDAThí[{l[×yÿûà%/)ROJ$õ mÉÔÃ–Ûs8~äe'A›vY¶¥V 6íC‹6Ãf-šbHƒÆmÚ+28ÍcÎ’ÔS–¤ÊËNb{rm«ÖËz¿¨·(R|Hä½çÛ%ŠÙ²%òÎ%y¾ï~¿ûÇ÷{|ÿß`[©<£ràeìàÈ'$"ÈÍ-¿;&
,Æ3È¢_’¥)Y”²pş;¿U6m:áÅ8íÇ~bpƒ£†€Z0ØAÈ'ÀÌ ™Òs¿<+ŒA’ERd‘r\QÅ iÀf1_3•³‡ö{.l¦}›Fø“KıGó¬Æ‡ª=*öàÁD @ ¥µÿñ/ŞJü †ô_²›ÍµšM#³ñb¡Íú¯‡îøx3ì¼cÂ—®5LÍÎ+Ÿ0š®“Çö¶–BÂÏşüLc@”¨€ˆ`ËSõâBë Íf~×^”ÿüÁ¦ªö;±÷¶	·¶¶Ê3Ê?ÎCMÍkçæC²¢HøÓ/CI¡-ƒ`:şå…×3œN8ùyq{Q^WA¾õ­"sôŸ8¿»¥Ûjo(ëû‘o|òñ©ÙyQÂâÅÅÚ:pÿ½MkÚ³Œ€s"[ş!¡‡!©/³syÖÜc/
WGîööï64x&6j»°Qs—{÷wôOîí÷=9>5gÒuœÓJéîAp!†„§Ò‹°\ˆ8ç+uöB)5ë:&¦æL½ı¾';ú'OŸ»Ü»£öo¨KøYç—FÆçşypx¢aq1ÆVûcBM²K?Üˆ»÷×-&,iq s×	ç¸|¥š¦!®éĞâÂÌÏ/`)¦¥ŒáUé0erW–¶W8Jÿîøİ5¿ÙtÂç.ôîïı¾¡	7×yVƒ’×%Å6|íñ ÃbŒCÓ94=á%}¹$¼«ƒë:t]Çââ"B¡0Bğ‚˜˜òƒ8_cCúıD‰ag•c°ºªü‰#‡ª/oáKíe=7Æ~ÓŞ=| IvU|ÕÃ PRœ—Ëİõ^pbĞtZf ÆX€1ø	l6!MED( "Up¢ÊØÒ’1^ÀôÌ,ÆÆ¦0=3ä¬–ù€awmUkõ.ç—ŞÂ˜¾)áÖÖV¹ß§½v½{è±D7Î£"c×Î*”–• ¿ €K²¡[b¸&ˆìšÀØ0ˆFÀ0/I‚?F¦YIˆj/ !,A˜ë´W#ìÕâ1¯ßï¦&¦Ñİ7„¥¥XÖ F£v{«ŞÚá”şøf³÷MgißºÑ7úÅHt‘åˆ`³šQW»•¤ƒ¢ÀšÆÎ	„«^·zƒ1–k•Š M~ "Ö=Ù%24É¢rÄPZúh¾Íæ6ª
ëìêG N¶\«$²Ènô|Ñhô<ào×ã³®‡ß?ßÓpåzç¥±‰Yuå>kÖM{±u»àp9#ƒüŸ²(¼¿S[a™\O÷ÍĞ5*NÆu~"‹ÿáø˜OmïìÁäŒÍ2ÆØê2ærEîj¨;xÿ½59ƒ“u=<=7óıQßŒš|Ëãhù³5OÅŞÆ:”•9f²ø0öoµUjÏMbù½Ø1şÌ¤ÈÃåå!ÉRñ…KWFVÚ¥®Ù£¾µÜ1ó} åÒ›snù¤íè¾Ñ‡s­‘ƒ„»kQæpÉ²ø´jŸ©w›7…l*êİæÕ$>#ËâÓe²¡»öÖÁ KÙ×m£§oôá–OÚn˜ğ˜oîSÓ~9±|$ÊÊ5q4ÖW£Ò]9«Èâ÷T˜â.3ù7›lî2“_…ù'Š,~¯²ªr¶±¡ ,„‰crÚ/ùæ~KWVÂï¿v¨»oì`B	­QÈ9GiI>¼Şê¨I‘Ÿ5’ùWÓ¶ŠlÓŒdş•I‘Ÿõz«£ö’ü„m´lcÒN"t÷|ïƒk‡²éÉJØï}gÎS•p"'04í­'“I=mTÄç·ƒlÓŒŠø¼É¤nÚ[O”~®†©~ÿ‚è†¾“MGVÂÃÃS'S»pj·q9JPîr1ıp+»q.¸ËL~&°–»œC.Gq†}É2<:}2›|á÷>jÛ3<6eåœƒ–=LD+×»ë«IQŒ§¶b‚ºUÔ»Í=Šb<ÕP_CÙæÎ9†Ç&­ï}Ô¶']6ƒp ùz$º˜}f–%8üÅí¡¶ş¢Óáè‘e)e¯Ö‘èáÈ×3ÄÒ¿Ì‡N¬xTç+5×9œÎ˜-y§ï4¨ØÔVX&Íªù%—£$gz˜H—Ë$¹W&´.½ÃíÒØ+ÛCéæ`„WÜU.N<1¡râ+5'@ äN—Éˆ´fæƒf¾’–­Öóóç¼•Ê-ä°!x=j÷ğˆms^ „Äî	-Ç¾³óAsºL†‡ƒÁ°°²Ã@|µ&E‘:×I¶Œ12•\=2eğËø"‰²$ÁÔ`ƒsÕh¼¸=Tn&Õx1—½‘èbFr”Ñ¥ã1Ä—î´."¤;Ú"İ
H’Ğ¾:×"Ó3Û§!ˆâÚjğD)¹gĞ¿p[[£[‰ !$œtN2}äÌ¸*ƒ°Q‘.fUîÌWn¦±›`¾r¥G²Ä?-O3Š’™ıf|c±¨˜õ²*-Å2"—ÿkÄ–b{8-wédg\®­5£}†ÏK
m«ëZÚ¾ñ\`aßV~»˜,ìËeoq‘-cpg¶Û‹béÙGRaÿà¨‡ˆ6¼y¿U "¡pÌ“Ë^»½(–.“a¼ÓY:•+TWŞ8{!çnÂvã³+¹–%§Ã>•.“ÅÃ%—ŒŠa­ğ²ÂÈb³³ßŞ:7ÇÄôì·×$:)ù»b4Àn/¾”.“AX5[Îîô”gdÉD»£{ğÁ—_?·k{(åÆË¯ŸÛÕÑ3ø`ª}´üŠ8G§ªÙz6].3ôb¬eß]õZjn™šoöúÔ¿ÿ©í¡•3~ÿSıƒ>5×ğÛ×T¯	Œµ¤ËeŞU¡ºİU]Å…¶%Ä	º¦áêõ¯œyó³ÃÛC-gŞüøğ•¶_Ñ5}Í$¥/_ÚPå®êÚU¡¦ËfqÍjŞé#÷ìK( „"}™´Î9FF&×»û~újËU×ÖÓ[‹W[>u]ïúéğè„!}I^¹gÌjŞélòY	ÑkMM³.§=c‹‡ˆ ë:._íÜ=Ôuã…ææfek)®¢¹¹Yê}¡õZ×îT{R³%—£MM³DôZ6Y	×ï°ôåY­§8~„ì/¬Cá»t¹ã‘‘¥ç¶ƒtss³Ò3²ôÜ¥Ë„Ã–Í&áşã‡gµ®ßaéË¦g B<U_W;æ­®Zñpz™ñ­W:¿ÑŞ»ğâ«-ŸnY÷~µåSW{ïÂ‹ÿs¥ó3³óÂ*Éµ'¼ÕU¨¯«ÄS¹tå$\WeìVUõ…‡:FÅEY½LD/\¾şDÇïú^zåÌÇ›>‘½ræãÃí­}/]h½şÄğè¸¼öş«uIq~è©ªúB]•±;—¾uß¶÷G\`ú;/¶6¼öúÛ…#9Ûªª‘ö4Ôô9K‹š¥Ï?ùä‘;Ú
zùås»|şÉoù&gm»Ş³3Yd9^ÃbQñ'?‚ƒ´ƒÄ“;Ô±\zoúB¼k(üÕÅÅèßÿà\É[ÿõâšÕ´$óŒG…«4VY^Öá,+şïâbÛÛ_{üşóŒ±ìzˆHxéõ÷ï™	<â›˜yxxt¢~dlÒ°ú†01A–%<öè}¸ÿ¾#ÓF£é¯k«Ì¿^ï7?@$Z†#3şCsó»ê‡ç[k+×$KÖàq»¢öÂ|_ÕÔ]hËë°ä™ÛŠ2N’è3˜cÃ *™¦;ÃKKèB¸a.°P†½3sçÀà˜‰8­IèÓ!I"ù<úè‰H¾ÍúT¨R}æ c™Û! ½cÛRœ›ı«Î*~tîBáŒvg0 
eÅ‹ù6KP–å¨,‰aA‚ À9·Æ5İÇM@È:>9mŒFc©Ìzâ  ò,f;zÇî½G/,)ú™"³¿¯v©Ùù€Î‘¨œÿ(XøòÅ‹­RËŸ`bjæÔgt+X‡Q6ùå'Zf/Â÷Æ¾p@³ÙòŞ„ |·®Â4x+<6tN«k8z'şÍHxé«mm×Ì~üººÀ×l5¤Ø(áõÛŒ¡ÖëÁñ£w£±qoX5+¿˜pª¶ÒtåV9lø¬eçHÔMºşçqÿeoo¯ıúï;q­­ƒ#¾ªº¬>ª
'šë±{O-ª«k¦dIø9Å_Şªg“¸­Ã¥½c›¦ÓŸÅãü›ápÄÛÓÓ+tttáj[&¦¦³œKŞlí{“Í€2{	škQ_ïEMM7›ÕnYNI"û÷[³Ùl¸-´‰–¡ÈéœĞtşH0¬èî¾şAbhØ‡P8²æ”Mòše;.‹ÕS9ªj‚»Ò	»;<nx½»`µZG$Qx[XK¨J=s³ÙxÓ	'ÑŞq	‚~RãìAóCÁ…ßø8|¾	LOÏ`zzşù æƒ!„Ã,-Å¡-ï{Ë²ƒA†Å¬Âfµ ßf…İ^Œ’’"88X¬yÓ¢ üVè·œ‹ï¬Tlá$:‡½€ö€®Ñ!°Ÿˆ<‘pÄä÷Ï!"
#‰"‹CÓ„%Q‚laVM°XÌ°Z­(((„jV£Œ±‘á²(±€Ô²^¸¸lú:úC;™Àöpëœj8§ZìD”O3db$ #¦1†8c3Ææ0%¬KX€Aât9WÖs»ØÒµÜ‰”ëœ{Á˜Dù f!"‰d `„8cL£›Ñ”(İÙv*>ÇçøYñ¿iweÔEËì    IEND®B`‚                                                                                                                                                                                                         ‰PNG

   IHDR   <   <   :üÙr   	pHYs       O%ÄÖ   $zTXtCreator  ™sLÉOJUpL+I-RpMKKM.) AzÎjzÅ  ÄIDAThí[{l[×yÿûà%/)ROJ¤^”-™²ä‡b»®›Äv^µã I»,ÒPì¡ıchÑÃ†aÒ¬ESiĞ¸K»bE§y,Y’zÊ’TyÙIlO®µ^Ö›’¨"Å‡DŞ{¾ıAQ¢ø-[Ò€!?àà\’çûî÷»ç;ç|ß¹‡Àçøÿ¶™Ê	ªÑ	n&Àbb°0@"‚ÜŞñ»£¢ÀL`	ƒ,%Yš‘EyØ gï<°ı÷›eÓ†¾rÅ»Ïİìh$8šhƒ„bÌ‰ =ûËÓ‚À$Y$E¹Á 'ÅSÒ¤A‘†mó³Q9}hÃ¹´oÃraèH ş³h|áÇîƒ¢Èõ ˜  ¬ö?ùÅ[©Àı«A–`³™ãV³iÌb6/µYÿõ®ƒÛ>Ş;o›ğ…Ë£­3ş¹o‡BÑc³°+<¿zü¶¹+ò~æçoäÃ ¢T D[‘ª——ZGl6ó»ö²âç¶Õwİ½·L¸³³SöÍ+ÿ0<2ã7æ"rÚà¦'>~hMù~şõœÎ&œ‰’â¢¤½¬¨·¤ØúV™9şHŞŠİÒ­uuWõ~ìœ~tÆ?g"JY¼Tat|¡ù(lEæ‘´`Î9ˆlé‡”†´¾Lø!Ùï¶—EãWW×ğ÷Z[¦Ök»°^3öwMŸò>>90éºÎiU‰/,b`ÈÆS„¥BœÀ9_®óÊ¨	\×150yïš>uæâÀşõÚ¿.—şğ³‡Ç&ÿ4â™j]XH°L©ÉtÉ*{)øúı†E#©tNà:Aã/õ@Ó4$5ZRÃ|4†¹¹y,&´Œ1¼¢3F£L®ºÊ®ZGåßŞó¥¦ßl8á3çöŒÿÇàè”‹ë<¯AékAà¬*Å‰î1šÎ¡é©^Ò—Jªwup]‡®ëXXX@$Åü|ÁPS3Aç«lÈ¾Ÿ(1l¯wŒ4Ö×<vøPãÅ#|¡k¸ªÿúÄoºú<ÒdWÄWz *Ê‹Qí´£¢¢%%¥ Æ<4Æ1† ùSÒTF„"²X-'ªK,.£ÑyÌúü˜˜˜Á¬oéY-÷3Ã®æúÎÆÎ‡ŞÄ˜¾!áÎÎNyÈ«½z­oô‘”ç‡Q‘±c{=*«*P\RÂ%ÙĞ'1\DvE`Ì¢10ÌI’LÉ/00	ñRMã% ƒ¥söj„½Z2áƒÂÌÔ,úG±¸˜Èû€Àh4Ğ.wı[ÛœÒ×o4{ßp–öğäõÁñ¯Äâ¬@œ ›ÕŒÍÛPW[KŠÑ8"
¬]`ìŒ@¸ìv©×cyF!  `<ıˆXßpl‡ÈĞ&‹ÊaCeåCÅ6›Ë¨*¬§w¡p4İrµ’Ø»>8ö£±áI ³Ÿ5{øı³ı­—®õ\˜˜ò«Ë÷Yµn2ØËmhİ¹jgÌ`ÿS…w!ğwšk-Óké¾zÇ"•àÂñ¤Î%É?˜œğª]=ı˜öW-cŒ­,cÕÎ²Ø­;ŞwwSÁàdÍø~0îõ©éçÉ°4–>[‹Tìİ³UUŸAÆş­¹^í¿¢i,=°ºG¢Ÿ™ÙSS[óç’,•Ÿ»p	¡pl¹]æš=îõ©5ß <RHoÁu¸ã“«G®?Xh4$Ü±§UÇ¨,‹O©&ñé—yCÈf¢ÅeîWMâÓ²,>Uå¨½cïNd)ÿº­sô?ØñÉÕ#ë&<áüpf6(§–TY¾&=-¨sÕùYü¾
óO]U¦àF“MÃUe
ª0ÿT‘Åï×Õ×ù÷´6”‡0qLÏå	oà‡…tå%üŞÙ+‡ú'¦”Ğ*…œsTVÃínŒ›ù#™ÕĞÀ´Í"›FCÓŒdş•I‘Ÿq»ãöŠâ”m´dcÚN"ô|ïƒ+yƒù¼„ƒÁÈwÁ°˜©„81 mo™Lê)£">·dÓhh`šQŸ3™ÔSm{[ˆ2ÂÏ•05œƒáÈwóéÈKØã™9éÂ™nSí¨@Mµs”	ìG›éÆ…àª2™À~TSí­v”çØ—.ñÙãùäs¿÷ÑÕİ‰+ç´ÔÃD´|½«¥‘Åxr3&¨›E‹ËÜ¯(Æ“­-M”oáœÃ31m}ï£«»³es‡¢±'bñ…ü3³,ÁápôCà/lµ5 ğœG¿,Kcx¥ÅŠÆÈËş"49¶Ü£:_®¹ÎátVÀl):u»AÅF ¹Ö2mVÍ/V;*
¦—¡¹È±l¹\Â¡ˆkyÈrém®j½¼5”nFxÙU_Í‰§&TN|¹æÄ
E\Ù29‘–o.læËiÙê`½´¸8à®S®o"‡uÁİ öyÆlÎy9 R»'´ûúçÂæl™œ‡£Âòñ•š8EêY#Ør0ÆÈhTºyd(Éá—óE,gi‚™ÁçªÑx~k¨Ü<Lªñ|!{cñ…œä(Ç¥“	Ä—î,‘Òmm‘n$IèZ‚«‘Lè¹í³¿DIm%x¢ŒÜ3œ¿¥­ÑÍD88ŸLNwN:}äÜ¸*‡°Q‘/äUÍÕm¤±`h®nÙ#YjÇŸ–¦EÉÍ~s¾±XTøƒ¡¼Ê‹‰œÈåÿ‰ÅÄnNK.vÆ¥ÚjQsÚçôyE©me]ËÚ7„æ÷m–á·Š@h~_!{ËËl9ƒ;‡°İ^–ÈÎ>Ò
‡FÆˆhİ›÷›"†F&
Ùk·—%²erŒw:+g
…j£IåÓç
î&l5Ş8}îÈ¨gR)´,9ö™l™<=\qÁ¨V/)Œ-$0å÷gkèÜS³şï¬Jt2òwÅh€İ^~![&‡°j¶œŞŞP““}¤íî¾‘^zıÌ­¡T/½~fGwÿÈ™öÑÒ{(âM5PÍÖÓÙr¹¡cûîhÑ2sËÌ|shÄ«ú‚Á'·†Vaø‚Á'‡F¼j¡á·¯­EëÈ–Ë!¼£Vw¹ê{ËKm9JˆtMÃåkı_{íÍÏîÚj¹xíÍïºtõú×tM_5IéK×e¥6Ô»ê{wÔªãÙ²yg\³ZtêğûR
(¥H_"­s±±iÃµ¾ÁŸ½Òq¹zóé­Æ+ŸV_ëı™g|Ê=Ç¤¯ß¹fµèT>ù¼„‰èÕ¶¶=şj§=g‹‡ˆ ë:.^îÙ5Ú{ıùööves)® ½½]í¾óJï®L{2³¥jGÚÚöø‰èÕ|:ònÙf,²ZOİÏ!ò¿°DcìÂÅîıc‹Ïnéööv¥lñÙ»OD£1–Ï&á¾{¡Èj=Õ²Í2˜OÏA„x²egó„»±~¹‡³Ë¬/(t^êùf×Àü¯t|ºiîıJÇ§Õ]ó/üÏ¥oúüsÂ
ÉÕ'ÜõhÙÙ<ˆ'é*Hxg½±OUÕçüòQ*/+ÉÛËDÏø”|îâµÇº7øâË¯}¼áÙË¯}|WWçà‹ç:¯=æŸ”Wß¥®(/Áƒ_>Jªª>¿³ŞØWHßšo»†bÕ`ú;çÏw¶¾úúÛˆDcÛªª‘v·6:+ËÚ%•Ï=şøáÛÚ
zé¥3;¼Áéo{§ı]½Ö¿=[`^ÃbQñGÀÁƒº@âñÖmêD!½7|!Ş;ıÆÂBü'ïp¦â­ÿú IMÇJZ’{Æ£¶º2QWSÕí¬*ÿïòrÛÛüè}gcù3ô,‘ğâëïßíó…Nx§|zÆ§ZÆ&¦+o³dYÂ#İ‹ûî=<k4šşª¹Şüëµîqã D¢Åûë¹PøïÛÛßU?<Û‰dR[&¸ú Yú´€WuÜ^Zì-²šúJmEİ–"s—QQ&I½sÂ ‰¨¡iº3º¸èˆÏG[¡ù–P8êöBÎá‘	qZ•ĞgC’DÜsøxè¡c±b›õÉHúôÆr·9ÖC &b¶Å$=˜õÿåGg??:só‘hN»œ3 ŒFªò…b›%,Ër\–Ä¨ a àœ[“šnN&“¦P(bœ5Æã‰ÌÌ{â  Š,f=rGï¾S/­(ûEf×X­æOä×K zÆâ.pşãPhş«çÏwJ|‚©ßM¨Ï3è–±£|òKO´Ê^†ûï½_üâÍf+z‚ğ½µ¦‘›á±®sZ½øœø·bÑÅo\½zÅüáÇŸ¡·w|ÕVC&õ^»½Àšİ¸çÈ—°gÏŞ¨jV~-0ádséÒÍrX÷YË±¸‹tıO“ÿ‹ûµß÷àÊÕŒŒy×«ê&°ò@êkhÛÓ‚]»›ÑØØ4#KÂÏ™(şòf{6[:\:0³i:ıI2É¿ÆÜııBww/._íÅÔÌlŞ“sé›­coàĞ¨²W mO3ZZÜhjjâf³Ú'ËÂIIdÿ~3c6Ÿ·„N"Ñ2ûCÓıšÎO„ÃáÚ¾¾ëÁğÈ8F=^D¢±U§lÒ×,ßqY¬œÊQU\uN4¸j°­Á·{¬Vë˜$
o‹ëˆÔ«¯İh6ŞpÂitÅªA?®qö€Îù‘ğ|…wr^ïfg}˜õ#8Â\8‚h4†ÅÅ$´¥}oY–`0È°˜UØ¬Û¬°ÛËQQQ§Ó§Ã‹µhV„ßJı–sñµ‚Š-!œFÏè‚Ğî×5:¤öQC,3ƒ„ÃaD"QDcq$IhzŠ°$J2Ìª	‹V«%%¥PÍjœ16,2\%v:Ö
×ƒÿÏC÷Pd;Ø~ .SçÔL€ˆŠ‰`&‚LŒ$ `Ä4ÆdQÆØfõŠë0Bœ.Êzn›ú¯–ëc±s7³ƒ¨Ä,D$ƒ ŒdŒi`cs š¡/ßNÅçøŸ#/ş¿ßgq„Ü·    IEND®B`‚                                                                                                                                                                                              lse>()
    }

    if (result.isError) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()
    }

    if (result.isSuccess) {
      expectTypeOf(result.data).toBeString()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()
    }

    expectTypeOf(result).not.toBeNever()

    // is always one of those four
    if (
      !result.isUninitialized &&
      !result.isLoading &&
      !result.isError &&
      !result.isSuccess
    ) {
      expectTypeOf(result).toBeNever()
    }
  })

  test('useMutation (with selectFromResult)', () => {
    const [_trigger, result] = api.endpoints.mutation.useMutation({
      selectFromResult({
        data,
        isLoading,
        isError,
        isSuccess,
        isUninitialized,
      }) {
        return {
          data: data ?? 'hi',
          isLoading,
          isError,
          isSuccess,
          isUninitialized,
        }
      },
    })

    expectTypeOf({
      data: '' as string,
      isUninitialized: false,
      isLoading: true,
      isSuccess: false,
      isError: false,
      reset: () => {},
    }).toMatchTypeOf(result)
  })

  test('useMutation TS4.1 union', () => {
    const [_trigger, result] = api.useMutationMutation()

    if (result.isUninitialized) {
      expectTypeOf(result.data).toBeUndefined()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()
    }

    if (result.isLoading) {
      expectTypeOf(result.data).toBeUndefined()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError | undefined
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()
    }

    if (result.isError) {
      expectTypeOf(result.data).toEqualTypeOf<string | undefined>()

      expectTypeOf(result.error).toEqualTypeOf<
        SerializedError | FetchBaseQueryError
      >()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isSuccess).toEqualTypeOf<false>()
    }

    if (result.isSuccess) {
      expectTypeOf(result.data).toBeString()

      expectTypeOf(result.error).toBeUndefined()

      expectTypeOf(result.isUninitialized).toEqualTypeOf<false>()

      expectTypeOf(result.isLoading).toEqualTypeOf<false>()

      expectTypeOf(result.isError).toEqualTypeOf<false>()
    }

    expectTypeOf(result).not.toBeNever()

    // is always one of those four
    if (
      !result.isUninitialized &&
      !result.isLoading &&
      !result.isError &&
      !result.isSuccess
    ) {
      expectTypeOf(result).toBeNever()
    }
  })
})

describe('"Typed" helper types', () => {
  test('useQuery', () => {
    expectTypeOf<TypedUseQuery<string, void, typeof baseQuery>>().toMatchTypeOf(
      api.endpoints.getTest.useQuery,
    )

    const result = api.endpoints.getTest.useQuery()

    expectTypeOf<
      TypedUseQueryHookResult<string, void, typeof baseQuery>
    >().toEqualTypeOf(result)
  })

  test('useQuery with selectFromResult', () => {
    const result = api.endpoints.getTest.useQuery(undefined, {
      selectFromResult: () => ({ x: true }),
    })

    expectTypeOf<
      TypedUseQueryHookResult<string, void, typeof baseQuery, { x: boolean }>
    >().toEqualTypeOf(result)
  })

  test('useQueryState', () => {
    expectTypeOf<
      TypedUseQueryState<string, void, typeof baseQuery>
    >().toMatchTypeOf(api.endpoints.getTest.useQueryState)

    const result = api.endpoints.getTest.useQueryState()

    expectTypeOf<
      TypedUseQueryStateResult<string, void, typeof baseQuery>
    >().toEqualTypeOf(result)
  })

  test('useQueryState with selectFromResult', () => {
    const result = api.endpoints.getTest.useQueryState(undefined, {
      selectFromResult: () => ({ x: true }),
    })

    expectTypeOf<
      TypedUseQueryStateResult<string, void, typeof baseQuery, { x: boolean }>
    >().toEqualTypeOf(result)
  })

  test('useQuerySubscription', () => {
    expectTypeOf<
      TypedUseQuerySubscription<string, void, typeof baseQuery>
    >().toMatchTypeOf(api.endpoints.getTest.useQuerySubscription)

    const result = api.endpoints.getTest.useQuerySubscription()

    expectTypeOf<
      TypedUseQuerySubscriptionResult<string, void, typeof baseQuery>
    >().toEqualTypeOf(result)
  })

  test('useLazyQuery', () => {
    expectTypeOf<
      TypedUseLazyQuery<string, void, typeof baseQuery>
    >().toMatchTypeOf(api.endpoints.getTest.useLazyQuery)

    const [trigger, result] = api.endpoints.getTest.useLazyQuery()

    expectTypeOf<
      TypedLazyQueryTrigger<string, void, typeof baseQuery>
    >().toMatchTypeOf(trigger)

    expectTypeOf<
      TypedUseQueryHookResult<string, void, typeof baseQuery>
    >().toMatchTypeOf(result)
  })

  test('useLazyQuery with selectFromResult', () => {
    const [trigger, result] = api.endpoints.getTest.useLazyQuery({
      selectFromResult: () => ({ x: true }),
    })

    expectTypeOf<
      TypedLazyQueryTrigger<string, void, typeof baseQuery>
    >().toMatchTypeOf(trigger)

    expectTypeOf<
      TypedUseQueryHookResult<string, void, typeof baseQuery, { x: boolean }>
    >().toMatchTypeOf(result)
  })

  test('useLazyQuerySubscription', () => {
    expectTypeOf<
      TypedUseLazyQuerySubscription<string, void, typeof baseQuery>
    >().toMatchTypeOf(api.endpoints.getTest.useLazyQuerySubscription)

    const [trigger] = api.endpoints.getTest.useLazyQuerySubscription()

    expectTypeOf<
      TypedLazyQueryTrigger<string, void, typeof baseQuery>
    >().toMatchTypeOf(trigger)
  })

  test('useMutation', () => {
    expectTypeOf<
      TypedUseMutation<string, void, typeof baseQuery>
    >().toMatchTypeOf(api.endpoints.mutation.useMutation)

    const [trigger, result] = api.endpoints.mutation.useMutation()

    expectTypeOf<
      TypedMutationTrigger<string, void, typeof baseQuery>
    >().toMatchTypeOf(trigger)

    expectTypeOf<
      TypedUseMutationResult<string, void, typeof baseQuery>
    >().toMatchTypeOf(result)
  })

  test('useQuery - defining selectFromResult separately', () => {
    const selectFromResult = (
      result: TypedUseQueryStateResult<string, void, typeof baseQuery>,
    ) => ({ x: true })

    const result = api.endpoints.getTest.useQuery(undefined, {
      selectFromResult,
    })

    expectTypeOf(result).toEqualTypeOf<
      TypedUseQueryHookResult<
        string,
        void,
        typeof baseQuery,
        ReturnType<typeof selectFromResult>
      >
    >()
  })

  test('useMutation - defining selectFromResult separately', () => {
    const selectFromResult = (
      result: Omit<
        TypedUseMutationResult<string, void, typeof baseQuery>,
        'reset' | 'originalArgs'
      >,
    ) => ({ x: true })

    const [trigger, result] = api.endpoints.mutation.useMutation({
      selectFromResult,
    })
    expectTypeOf(result).toEqualTypeOf<
      TypedUseMutationResult<
        string,
        void,
        typeof baseQuery,
        ReturnType<typeof selectFromResult>
      >
    >()
  })
})
