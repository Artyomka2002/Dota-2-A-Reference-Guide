import { buildGetDefaultMiddleware } from '@internal/getDefaultMiddleware'
import type {
  Action,
  Dispatch,
  Middleware,
  ThunkAction,
  ThunkDispatch,
  ThunkMiddleware,
  Tuple,
  UnknownAction,
} from '@reduxjs/toolkit'
import { configureStore } from '@reduxjs/toolkit'

declare const middleware1: Middleware<{
  (_: string): number
}>

declare const middleware2: Middleware<{
  (_: number): string
}>

type ThunkReturn = Promise<'thunk'>
declare const thunkCreator: () => () => ThunkReturn

const getDefaultMiddleware = buildGetDefaultMiddleware()

describe('type tests', () => {
  test('prepend single element', () => {
    const store = configureStore({
      reducer: () => 0,
      middleware: (gDM) => gDM().prepend(middleware1),
    })

    expectTypeOf(store.dispatch('foo')).toBeNumber()

    expectTypeOf(store.dispatch(thunkCreator())).toEqualTypeOf<ThunkReturn>()

    expectTypeOf(store.dispatch('foo')).not.toBeString()
  })

  test('prepend multiple (rest)', () => {
    const store = configureStore({
      reducer: () => 0,
      middleware: (gDM) => gDM().prepend(middleware1, middleware2),
    })

    expectTypeOf(store.dispatch('foo')).toBeNumber()

    expectTypeOf(store.dispatch(5)).toBeString()

    expectTypeOf(store.dispatch(thunkCreator())).toEqualTypeOf<ThunkReturn>()

    expectTypeOf(store.dispatch('foo')).not.toBeString()
  })

  test('prepend multiple (array notation)', () => {
    const store = configureStore({
      reducer: () => 0,
      middleware: (gDM) => gDM().prepend([middleware1, middleware2] as const),
    })

    expectTypeOf(store.dispatch('foo')).toBeNumber()

    expectTypeOf(store.dispatch(5)).toBeString()

    expectTypeOf(store.dispatch(thunkCreator())).toEqualTypeOf<ThunkReturn>()

    expectTypeOf(store.dispatch('foo')).not.toBeString()
  })

  test('concat single element', () => {
    const store = configureStore({
      reducer: () => 0,
      middleware: (gDM) => gDM().concat(middleware1),
    })

    expectTypeOf(store.dispatch('foo')).toBeNumber()

    expectTypeOf(store.dispatch(thunkCreator())).toEqualTypeOf<ThunkReturn>()

    expectTypeOf(store.dispatch('foo')).not.toBeString()
  })

  test('prepend multiple (rest)', () => {
    const store = configureStore({
      reducer: () => 0,
      middleware: (gDM) => gDM().concat(middleware1, middleware2),
    })

    expectTypeOf(store.dispatch('foo')).toBeNumber()

    expectTypeOf(store.dispatch(5)).toBeString()

    expectTypeOf(store.dispatch(thunkCreator())).toEqualTypeOf<ThunkReturn>()

    expectTypeOf(store.dispatch('foo')).not.toBeString()
  })

  test('concat multiple (array notation)', () => {
    const store = configureStore({
      reducer: () => 0,
      middleware: (gDM) => gDM().concat([middleware1, middleware2] as const),
    })

    expectTypeOf(store.dispatch('foo')).toBeNumber()

    expectTypeOf(store.dispatch(5)).toBeString()

    expectTypeOf(store.dispatch(thunkCreator())).toEqualTypeOf<ThunkReturn>()

    expectTypeOf(store.dispatch('foo')).not.toBeString()
  })

  test('concat and prepend', () => {
    const store = configureStore({
      reducer: () => 0,
      middleware: (gDM) => gDM().concat(middleware1).prepend(middleware2),
    })

    expectTypeOf(store.dispatch('foo')).toBeNumber()

    expectTypeOf(store.dispatch(5)).toBeString()

    expectTypeOf(store.dispatch(thunkCreator())).toEqualTypeOf<ThunkReturn>()

    expectTypeOf(store.dispatch('foo')).not.toBeString()
  })

  test('allows passing options to thunk', () => {
    const extraArgument = 42 as const

    const m2 = getDefaultMiddleware({
      thunk: false,
    })

    expectTypeOf(m2).toMatchTypeOf<Tuple<[]>>()

    const dummyMiddleware: Middleware<
      {
        (action: Action<'actionListenerMiddleware/add'>): () => void
      },
      { counter: number }
    > = (storeApi) => (next) => (action) => {
      return next(action)
    }

    const dummyMiddleware2: Middleware<{}, { counter: n//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac

import moment from '../moment';

var translator = {
    words: {
        //Different grammatical cases
        ss: ['sekund', 'sekunda', 'sekundi'],
        m: ['jedan minut', 'jednog minuta'],
        mm: ['minut', 'minuta', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mjesec', 'mjeseca', 'mjeseci'],
        yy: ['godina', 'godine', 'godina'],
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1
            ? wordKey[0]
            : number >= 2 && number <= 4
              ? wordKey[1]
              : wordKey[2];
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return (
                number +
                ' ' +
                translator.correctGrammaticalCase(number, wordKey)
            );
        }
    },
};

export default moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
        '_'
    )