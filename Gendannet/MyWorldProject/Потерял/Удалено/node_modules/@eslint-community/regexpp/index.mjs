/**
 * @fileoverview This rule sets a specific indentation style and width for your code
 *
 * @author Teddy Katz
 * @author Vitaly Puzrin
 * @author Gyandeep Singh
 * @deprecated in ESLint v8.53.0
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const KNOWN_NODES = new Set([
    "AssignmentExpression",
    "AssignmentPattern",
    "ArrayExpression",
    "ArrayPattern",
    "ArrowFunctionExpression",
    "AwaitExpression",
    "BlockStatement",
    "BinaryExpression",
    "BreakStatement",
    "CallExpression",
    "CatchClause",
    "ChainExpression",
    "ClassBody",
    "ClassDeclaration",
    "ClassExpression",
    "ConditionalExpression",
    "ContinueStatement",
    "DoWhileStatement",
    "DebuggerStatement",
    "EmptyStatement",
    "ExperimentalRestProperty",
    "ExperimentalSpreadProperty",
    "ExpressionStatement",
    "ForStatement",
    "ForInStatement",
    "ForOfStatement",
    "FunctionDeclaration",
    "FunctionExpression",
    "Identifier",
    "IfStatement",
    "Literal",
    "LabeledStatement",
    "LogicalExpression",
    "MemberExpression",
    "MetaProperty",
    "MethodDefinition",
    "NewExpression",
    "ObjectExpression",
    "ObjectPattern",
    "PrivateIdentifier",
    "Program",
    "Property",
    "PropertyDefinition",
    "RestElement",
    "ReturnStatement",
    "SequenceExpression",
    "SpreadElement",
    "StaticBlock",
    "Super",
    "SwitchCase",
    "SwitchStatement",
    "TaggedTemplateExpression",
    "TemplateElement",
    "TemplateLiteral",
    "ThisExpression",
    "ThrowStatement",
    "TryStatement",
    "UnaryExpression",
    "UpdateExpression",
    "VariableDeclaration",
    "VariableDeclarator",
    "WhileStatement",
    "WithStatement",
    "YieldExpression",
    "JSXFragment",
    "JSXOpeningFragment",
    "JSXClosingFragment",
    "JSXIdentifier",
    "JSXNamespacedName",
    "JSXMemberExpression",
    "JSXEmptyExpression",
    "JSXExpressionContainer",
    "JSXElement",
    "JSXClosingElement",
    "JSXOpeningElement",
    "JSXAttribute",
    "JSXSpreadAttribute",
    "JSXText",
    "ExportDefaultDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration",
    "ExportSpecifier",
    "ImportDeclaration",
    "ImportSpecifier",
    "ImportDefaultSpecifier",
    "ImportNamespaceSpecifier",
    "ImportExpression"
]);

/*
 * General rule strategy:
 * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another
 *    specified token or to the first column.
 * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a
 *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly
 *    brace of the BlockStatement.
 * 3. After traversing the AST, calculate the expected indentation levels of every token according to the
 *    OffsetStorage container.
 * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,
 *    and report the token if the two values are not equal.
 */


/**
 * A mutable map that stores (key, value) pairs. The keys are numeric indices, and must be unique.
 * This is intended to be a generic wrapper around a map with non-negative integer keys, so that the underlying implementation
 * can easily be swapped out.
 */
class IndexMap {

    /**
     * Creates an empty map
     * @param {number} maxKey The maximum key
     */
    constructor(maxKey) {

        // Initializing the array with the maximum expected size avoids dynamic reallocations that could degrade performance.
        this._values = Array(maxKey + 1);
    }

    /**
     * Inserts an entry into the map.
     * @param {number} key The entry's key
     * @param {any} value The entry's value
     * @returns {void}
     */
    insert(key, value) {
        this._values[key] = value;
    }

    /**
     * Finds the value of the entry with the largest key less than or equal to the provided key
     * @param {number} key The provided key
     * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.
     */
    findLastNotAfter(key) {
        const values = this._values;

        for (let index = key; index >= 0; index--) {
            const value = values[index];

            if (value) {
                return value;
            }
        }
        return void 0;
    }

    /**
     * Deletes all of the keys in the interval [start, end)
     * @param {number} start The start of the range
     * @param {number} end The end of the range
     * @returns {void}
     */
    deleteRange(start, end) {
        this._values.fill(void 0, start, end);
    }
}

/**
 * A helper class to get token-based info related to indentation
 */
class TokenInfo {

    /**
     * @param {SourceCode} sourceCode A SourceCode object
     */
    constructor(sourceCode) {
        this.sourceCode = sourceCode;
        this.firstTokensByLineNumber = new Map();
        const tokens = sourceCode.tokensAndComments;

        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];

            if (!this.firstTokensByLineNumber.has(token.loc.start.line)) {
                this.firstTokensByLineNumber.set(token.loc.start.line, token);
            }
            if (!this.firstTokensByLineNumber.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
                this.firstTokensByLineNumber.set(token.loc.end.line, token);
            }
        }
    }

    /**
     * Gets the first token on a given token's line
     * @param {Token|ASTNode} token a node or token
     * @returns {Token} The first token on the given line
     */
    getFirstTokenOfLine(token) {
        return this.firstTokensByLineNumber.get(token.loc.start.line);
    }

    /**
     * Determines whether a token is the first token in its line
     * @param {Token} token The token
     * @returns {boolean} `true` if the token is the first on its line
     */
    isFirstTokenOfLine(token) {
        return this.getFirstTokenOfLine(token) === token;
    }

    /**
     * Get the actual indent of a token
     * @param {Token} token Token to examine. This should be the first token on its line.
     * @returns {string} The indentation characters that precede the token
     */
    getTokenIndent(token) {
        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
    }
}

/**
 * A class to store information on desired offsets of tokens from each other
 */
class OffsetStorage {

    /**
     * @param {TokenInfo} tokenInfo a TokenInfo instance
     * @param {number} indentSize The desired size of each indentation level
     * @param {string} indentType The indentation character
     * @param {number} maxIndex The maximum end index of any token
     */
    constructor(tokenInfo, indentSize, indentType, maxIndex) {
        this._tokenInfo = tokenInfo;
        this._indentSize = indentSize;
        this._indentType = indentType;

        this._indexMap = new IndexMap(maxIndex);
        this._indexMap.insert(0, { offset: 0, from: null, force: false });

        this._lockedFirstTokens = new WeakMap();
        this._desiredIndentCache = new WeakMap();
        this._ignoredTokens = new WeakSet();
    }

    _getOffsetDescriptor(token) {
        return this._indexMap.findLastNotAfter(token.range[0]);
    }

    /**
     * Sets the offset column of token B to match the offset column of token A.
     * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In
     * most cases, `setDesiredOffset` should be used instead.
     * @param {Token} baseToken The first token
     * @param {Token} offsetToken The second token, whose offset should be matched to the first token
     * @returns {void}
     */
    matchOffsetOf(baseToken, offsetToken) {

        /*
         * lockedFirstTokens is a map from a token whose indentation is controlled by the "first" option to
         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first
         * token of each element in the array after the first will be mapped to the first token of the first
         * element. The desired indentation of each of these tokens is computed based on the desired indentation
         * of the "first" element, rather than through the normal offset mechanism.
         */
        this._lockedFirstTokens.set(offsetToken, baseToken);
    }

    /**
     * Sets the desired offset of a token.
     *
     * This uses a line-based offset collapsing behavior to handle tokens on the same line.
     * For example, consider the following two cases:
     *
     * (
     *     [
     *         bar
     *     ]
     * )
     *
     * ([
     *     bar
     * ])
     *
     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from
     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is
     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)
     * from the start of its line.
     *
     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level
     * between the `(` and the `[` tokens gets "collapsed" because the two tokens are on the same line. As a result, the
     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented
     * by 1 indent level from the start of the line.
     *
     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,
     * without needing to check which lines those tokens are on.
     *
     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive
     * behavior can occur. For example, consider the following cases:
     *
     * foo(
     * ).
     *     bar(
     *         baz
     *     )
     *
     * foo(
     * ).bar(
     *     baz
     * )
     *
     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`
     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`
     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no
     * collapsing would occur).
     *
     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and
     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed
     * in the second case.
     * @param {Token} token The token
     * @param {Token} fromToken The token that `token` should be offset from
     * @param {number} offset The desired indent level
     * @returns {void}
     */
    setDesiredOffset(token, fromToken, offset) {
        return this.setDesiredOffsets(token.range, fromToken, offset);
    }

    /**
     * Sets the desired offset of all tokens in a range
     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.
     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains
     * it). This means that the offset of each token is updated O(AST depth) times.
     * It would not be performant to store and update the offsets for each token independently, because the rule would end
     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.
     *
     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following
     * list could represent the state of the offset tree at a given point:
     *
     * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file
     * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token
     * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token
     * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token
     * - Tokens starting in the interval [820, âˆž) are offset by 1 indent level from the `baz` token
     *
     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:
     * `setDesiredOffsets([30, 43], fooToken, 1);`
     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.
     * @param {Token} fromToken The token that this is offset from
     * @param {number} offset The desired indent level
     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.
     * @returns {void}
     */
    setDesiredOffsets(range, fromToken, offset, force) {

        /*
         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset
         * descriptor. The tree for the example above would have the following nodes:
         *
         * * key: 0, value: { offset: 0, from: null }
         * * key: 15, value: { offset: 1, from: barToken }
         * * key: 30, value: { offset: 1, from: fooToken }
         * * key: 43, value: { offset: 2, from: barToken }
         * * key: 820, value: { offset: 1, from: bazToken }
         *
         * To find the offset descriptor for any given token, one needs to find the node with the largest key
         * which is <= token.start. To make this operation fast, the nodes are stored in a map indexed by key.
         */

        const descriptorToInsert = { offset, from: fromToken, force };

        const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);

        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);

        // First, remove any existing nodes in the range from the map.
        this._indexMap.deleteRange(range[0] + 1, range[1]);

        // Insert a new node into the map for this range
        this._indexMap.insert(range[0], descriptorToInsert);

        /*
         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,
         * even if it's in the current range.
         */
        if (fromTokenIsInRange) {
            this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);
            this._indexMap.insert(fromToken.range[1], descriptorToInsert);
        }

        /*
         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following
         * tokens the same as it was before.
         */
        this._indexMap.insert(range[1], descriptorAfterRange);
    }

    /**
     * Gets the desired indent of a token
     * @param {Token} token The token
     * @returns {string} The desired indent of the token
     */
    getDesiredIndent(token) {
        if (!this._desiredIndentCache.has(token)) {

            if (this._ignoredTokens.has(token)) {

                /*
                 * If the token is ignored, use the actual indent of the token as the desired indent.
                 * This ensures that no errors are reported for this token.
                 */
                this._desiredIndentCache.set(
                    token,
                    this._tokenInfo.getTokenIndent(token)
                );
            } else if (this._lockedFirstTokens.has(token)) {
                const firstToken = this._lockedFirstTokens.get(token);

                this._desiredIndentCache.set(
                    token,

                    // (indentation for the first element's line)
                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +

                        // (space between the start of the first element's line and the first element)
                        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column)
                );
            } else {
                const offsetInfo = this._getOffsetDescriptor(token);
                const offset = (
                    offsetInfo.from &&
                    offsetInfo.from.loc.start.line === token.loc.start.line &&
                    !/^\s*?\n/u.test(token.value) &&
                    !offsetInfo.force
                ) ? 0 : offsetInfo.offset * this._indentSize;

                this._desiredIndentCache.set(
                    token,
                    (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset)
                );
            }
        }
        return this._desiredIndentCache.get(token);
    }

    /**
     * Ignores a token, preventing it from being reported.
     * @param {Token} token The token
     * @returns {void}
     */
    ignoreToken(token) {
        if (this._tokenInfo.isFirstTokenOfLine(token)) {
            this._ignoredTokens.add(token);
        }
    }

    /**
     * Gets the first token that the given token's indentation is dependent on
     * @param {Token} token The token
     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level
     */
    getFirstDependency(token) {
        return this._getOffsetDescriptor(token).from;
    }
}

const ELEMENT_LIST_SCHEMA = {
    oneOf: [
        {
            type: "integer",
            minimum: 0
        },
        {
            enum: ["first", "off"]
        }
    ]
};

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce consistent indentation",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/indent"
        },

        fixable: "whitespace",

        schema: [
            {
                oneOf: [
                    {
                        enum: ["tab"]
                    },
                    {
                        type: "integer",
                        minimum: 0
                    }
                ]
            },
            {
                type: "object",
                properties: {
                    SwitchCase: {
                        type: "integer",
                        minimum: 0,
                        default: 0
                    },
                    VariableDeclarator: {
                        oneOf: [
                            ELEMENT_LIST_SCHEMA,
                            {
                                type: "object",
                                properties: {
                                    var: ELEMENT_LIST_SCHEMA,
                                    let: ELEMENT_LIST_SCHEMA,
                                    const: ELEMENT_LIST_SCHEMA
                                },
                                additionalProperties: false
                            }
                        ]
                    },
                    outerIIFEBody: {
                        oneOf: [
                            {
                                type: "integer",
                                minimum: 0
                            },
                            {
                                enum: ["off"]
                            }
                        ]
                    },
                    MemberExpression: {
                        oneOf: [
                            {
                                type: "integer",
                                minimum: 0
                            },
                            {
                                enum: ["off"]
                            }
                        ]
                    },
                    FunctionDeclaration: {
                        type: "object",
                        properties: {
                            parameters: ELEMENT_LIST_SCHEMA,
                            body: {
                                type: "integer",
                                minimum: 0
                            }
                        },
                        additionalProperties: false
                    },
                    FunctionExpression: {
                        type: "object",
                        properties: {
                            parameters: ELEMENT_LIST_SCHEMA,
                            body: {
                                type: "integer",
                                minimum: 0
                            }
                        },
                        additionalProperties: false
                    },
                    StaticBlock: {
                        type: "object",
                        properties: {
                            body: {
                                type: "integer",
                                minimum: 0
                            }
                        },
                        additionalProperties: false
                    },
                    CallExpression: {
                        type: "object",
                        properties: {
                            arguments: ELEMENT_LIST_SCHEMA
                        },
                        additionalProperties: false
                    },
                    ArrayExpression: ELEMENT_LIST_SCHEMA,
                    ObjectExpression: ELEMENT_LIST_SCHEMA,
                    ImportDeclaration: ELEMENT_LIST_SCHEMA,
                    flatTernaryExpressions: {
                        type: "boolean",
                        default: false
                    },
                    offsetTernaryExpressions: {
                        type: "boolean",
                        default: false
                    },
                    ignoredNodes: {
                        type: "array",
                        items: {
                            type: "string",
                            not: {
                                pattern: ":exit$"
                            }
                        }
                    },
                    ignoreComments: {
                        type: "boolean",
                        default: false
                    }
                },
                additionalProperties: false
            }
        ],
        messages: {
            wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
        }
    },

    create(context) {
        const DEFAULT_VARIABLE_INDENT = 1;
        const DEFAULT_PARAMETER_INDENT = 1;
        const DEFAULT_FUNCTION_BODY_INDENT = 1;

        let indentType = "space";
        let indentSize = 4;
        const options = {
            SwitchCase: 0,
            VariableDeclarator: {
                var: DEFAULT_VARIABLE_INDENT,
                let: DEFAULT_VARIABLE_INDENT,
                const: DEFAULT_VARIABLE_INDENT
            },
            outerIIFEBody: 1,
            FunctionDeclaration: {
                parameters: DEFAULT_PARAMETER_INDENT,
                body: DEFAULT_FUNCTION_BODY_INDENT
            },
            FunctionExpression: {
                parameters: DEFAULT_PARAMETER_INDENT,
                body: DEFAULT_FUNCTION_BODY_INDENT
            },
            StaticBlock: {
                body: DEFAULT_FUNCTION_BODY_INDENT
            },
            CallExpression: {
                arguments: DEFAULT_PARAMETER_INDENT
            },
            MemberExpression: 1,
            ArrayExpression: 1,
            ObjectExpression: 1,
            ImportDeclaration: 1,
            flatTernaryExpressions: false,
            ignoredNodes: [],
            ignoreComments: false
        };

        if (context.options.length) {
            if (context.options[0] === "tab") {
                indentSize = 1;
                indentType = "tab";
            } else {
                indentSize = context.options[0];
                indentType = "space";
            }

            if (context.options[1]) {
                Object.assign(options, context.options[1]);

                if (typeof options.VariableDeclarator === "number" || options.VariableDeclarator === "first") {
                    options.VariableDeclarator = {
                        var: options.VariableDeclarator,
                        let: options.VariableDeclarator,
                        const: options.VariableDeclarator
                    };
                }
            }
        }

        const sourceCode = context.sourceCode;
        const tokenInfo = new TokenInfo(sourceCode);
        const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "\t", sourceCode.text.length);
        const parameterParens = new WeakSet();

        /**
         * Creates an error message for a line, given the expected/actual indentation.
         * @param {int} expectedAmount The expected amount of indentation characters for this line
         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line
         * @param {int} actualTabs The actual number of indentation tabs that were found on this line
         * @returns {string} An error message for this line
         */
        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`; // e.g. "2 tabs"
            const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`; // e.g. "space"
            const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`; // e.g. "tabs"
            let foundStatement;

            if (actualSpaces > 0) {

                /*
                 * Abbreviate the message if the expected indentation is also spaces.
                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'
                 */
                foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
            } else if (actualTabs > 0) {
                foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
            } else {
                foundStatement = "0";
            }
            return {
                expected: expectedStatement,
                actual: foundStatement
            };
        }

        /**
         * Reports a given indent violation
         * @param {Token} token Token violating the indent rule
         * @param {string} neededIndent Expected indentation string
         * @returns {void}
         */
        function report(token, neededIndent) {
            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
            const numSpaces = actualIndent.filter(char => char === " ").length;
            const numTabs = actualIndent.filter(char => char === "\t").length;

            context.report({
                node: token,
                messageId: "wrongIndentation",
                data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),
                loc: {
                    start: { line: token.loc.start.line, column: 0 },
                    end: { line: token.loc.start.line, column: token.loc.start.column }
                },
                fix(fixer) {
                    const range = [token.range[0] - token.loc.start.column, token.range[0]];
                    const newText = neededIndent;

                    return fixer.replaceTextRange(range, newText);
                }
            });
        }

        /**
         * Checks if a token's indentation is correct
         * @param {Token} token Token to examine
         * @param {string} desiredIndent Desired indentation of the string
         * @returns {boolean} `true` if the token's indentation is correct
         */
        function validateTokenIndent(token, desiredIndent) {
            const indentation = tokenInfo.getTokenIndent(token);

            return indentation === desiredIndent ||

                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.
                indentation.includes(" ") && indentation.includes("\t");
        }

        /**
         * Check to see if the node is a file level IIFE
         * @param {ASTNode} node The function node to check.
         * @returns {boolean} True if the node is the outer IIFE
         */
        function isOuterIIFE(node) {

            /*
             * Verify that the node is an IIFE
             */
            if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
                return false;
            }

            /*
             * Navigate legal ancestors to determine whether this IIFE is outer.
             * A "legal ancestor" is an expression or statement that causes the function to get executed immediately.
             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.
             */
            let statement = node.parent && node.parent.parent;

            while (
                statement.type === "UnaryExpression" && ["!", "~", "+", "-"].includes(statement.operator) ||
                statement.type === "AssignmentExpression" ||
                statement.type === "LogicalExpression" ||
                statement.type === "SequenceExpression" ||
                statement.type === "VariableDeclarator"
            ) {
                statement = statement.parent;
            }

            return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
        }

        /**
         * Counts the number of linebreaks that follow the last non-whitespace character in a string
         * @param {string} string The string to check
         * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,
         * or the total number of linebreaks if the string is all whitespace.
         */
        function countTrailingLinebreaks(string) {
            const trailingWhitespace = string.match(/\s*$/u)[0];
            const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());

            return linebreakMatches === null ? 0 : linebreakMatches.length;
        }

        /**
         * Check indentation for lists of elements (arrays, objects, function params)
         * @param {ASTNode[]} elements List of elements that should be offset
         * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['
         * @param {Token} endToken The end token of the list, e.g. ']'
         * @param {number|string} offset The amount that the elements should be offset
         * @returns {void}
         */
        function addElementListIndent(elements, startToken, endToken, offset) {

            /**
             * Gets the first token of a given element, including surrounding parentheses.
             * @param {ASTNode} element A node in the `elements` list
             * @returns {Token} The first token of this element
             */
            function getFirstToken(element) {
                let token = sourceCode.getTokenBefore(element);

                while (astUtils.isOpeningParenToken(token) && token !== startToken) {
                    token = sourceCode.getTokenBefore(token);
                }
                return sourceCode.getTokenAfter(token);
            }

            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)
            offsets.setDesiredOffsets(
                [startToken.range[1], endToken.range[0]],
                startToken,
                typeof offset === "number" ? offset : 1
            );
            offsets.setDesiredOffset(endToken, startToken, 0);

            // If the preference is "first" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.
            if (offset === "first" && elements.length && !elements[0]) {
                return;
            }
            elements.forEach((element, index) => {
                if (!element) {

                    // Skip holes in arrays
                    return;
                }
                if (offset === "off") {

                    // Ignore the first token of every element if the "off" option is used
                    offsets.ignoreToken(getFirstToken(element));
                }

                // Offset the following elements correctly relative to the first element
                if (index === 0) {
                    return;
                }
                if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
                } else {
                    const previousElement = elements[index - 1];
                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
                    const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);

                    if (
                        previousElement &&
                        previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line
                    ) {
                        offsets.setDesiredOffsets(
                            [previousElement.range[1], element.range[1]],
                            firstTokenOfPreviousElement,
                            0
                        );
                    }
                }
            });
        }

        /**
         * Check and decide whether to check for indentation for blockless nodes
         * Scenarios are for or while statements without braces around them
         * @param {ASTNode} node node to examine
         * @returns {void}
         */
        function addBlocklessNodeIndent(node) {
            if (node.type !== "BlockStatement") {
                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);

                let firstBodyToken = sourceCode.getFirstToken(node);
                let lastBodyToken = sourceCode.getLastToken(node);

                while (
                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&
                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))
                ) {
                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
                }

                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
            }
        }

        /**
         * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)
         * @param {ASTNode} node A CallExpression or NewExpression node
         * @returns {void}
         */
        function addFunctionCallIndent(node) {
            let openingParen;

            if (node.arguments.length) {
                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
            } else {
                openingParen = sourceCode.getLastToken(node, 1);
            }
            const closingParen = sourceCode.getLastToken(node);

            parameterParens.add(openingParen);
            parameterParens.add(closingParen);

            /*
             * If `?.` token exists, set desired offset for that.
             * This logic is copied from `MemberExpression`'s.
             */
            if (node.optional) {
                const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);
                const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, { filter: astUtils.isClosingParenToken }).length;
                const firstTokenOfCallee = calleeParenCount
                    ? sourceCode.getTokenBefore(node.callee, { skip: calleeParenCount - 1 })
                    : sourceCode.getFirstToken(node.callee);
                const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);
                const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line
                    ? lastTokenOfCallee
                    : firstTokenOfCallee;

                offsets.setDesiredOffset(dotToken, offsetBase, 1);
            }

            const offsetAfterToken = node.callee.type === "TaggedTemplateExpression" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;
            const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);

            offsets.setDesiredOffset(openingParen, offsetToken, 0);

            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
        }

        /**
         * Checks the indentation of parenthesized values, given a list of tokens in a program
         * @param {Token[]} tokens A list of tokens
         * @returns {void}
         */
        function addParensIndent(tokens) {
            const parenStack = [];
            const parenPairs = [];

            for (let i = 0; i < tokens.length; i++) {
                const nextToken = tokens[i];

                if (astUtils.isOpeningParenToken(nextToken)) {
                    parenStack.push(nextToken);
                } else if (astUtils.isClosingParenToken(nextToken)) {
                    parenPairs.push({ left: parenStack.pop(), right: nextToken });
                }
            }

            for (let i = parenPairs.length - 1; i >= 0; i--) {
                const leftParen = parenPairs[i].left;
                const rightParen = parenPairs[i].right;

                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.
                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));

                    parenthesizedTokens.forEach(token => {
                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
                            offsets.setDesiredOffset(token, leftParen, 1);
                        }
                    });
                }

                offsets.setDesiredOffset(rightParen, leftParen, 0);
            }
        }

        /**
         * Ignore all tokens within an unknown node whose offset do not depend
         * on another token's offset within the unknown node
         * @param {ASTNode} node Unknown Node
         * @returns {void}
         */
        function ignoreNode(node) {
            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));

            unknownNodeTokens.forEach(token => {
                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);

                    if (token === firstTokenOfLine) {
                        offsets.ignoreToken(token);
                    } else {
                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);
                    }
                }
            });
        }

        /**
         * Check whether the given token is on the first line of a statement.
         * @param {Token} token The token to check.
         * @param {ASTNode} leafNode The expression node that the token belongs directly.
         * @returns {boolean} `true` if the token is on the first line of a statement.
         */
        function isOnFirstLineOfStatement(token, leafNode) {
            let node = leafNode;

            while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
                node = node.parent;
            }
            node = node.parent;

            return !node || node.loc.start.line === token.loc.start.line;
        }

        /**
         * Check whether there are any blank (whitespace-only) lines between
         * two tokens on separate lines.
         * @param {Token} firstToken The first token.
         * @param {Token} secondToken The second token.
         * @returns {boolean} `true` if the tokens are on separate lines and
         *   there exists a blank line between them, `false` otherwise.
         */
        function hasBlankLinesBetween(firstToken, secondToken) {
            const firstTokenLine = firstToken.loc.end.line;
            const secondTokenLine = secondToken.loc.start.line;

            if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {
                return false;
            }

            for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {
                if (!tokenInfo.firstTokensByLineNumber.has(line)) {
                    return true;
                }
            }

            return false;
        }

        const ignoredNodeFirstTokens = new Set();

        const baseOffsetListeners = {
            "ArrayExpression, ArrayPattern"(node) {
                const openingBracket = sourceCode.getFirstToken(node);
                const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find(_ => _) || openingBracket, astUtils.isClosingBracketToken);

                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
            },

            "ObjectExpression, ObjectPattern"(node) {
                const openingCurly = sourceCode.getFirstToken(node);
                const closingCurly = sourceCode.getTokenAfter(
                    node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,
                    astUtils.isClosingBraceToken
                );

                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
            },

            ArrowFunctionExpression(node) {
                const maybeOpeningParen = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });

                if (astUtils.isOpeningParenToken(maybeOpeningParen)) {
                    const openingParen = maybeOpeningParen;
                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);

                    parameterParens.add(openingParen);
                    parameterParens.add(closingParen);
                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
                }

                addBlocklessNodeIndent(node.body);
            },

            AssignmentExpression(node) {
                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);

                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
                offsets.ignoreToken(operator);
                offsets.ignoreToken(sourceCode.getTokenAfter(operator));
            },

            "BinaryExpression, LogicalExpression"(node) {
                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);

                /*
                 * For backwards compatibility, don't check BinaryExpression indents, e.g.
                 * var foo = bar &&
                 *                   baz;
                 */

                const tokenAfterOperator = sourceCode.getTokenAfter(operator);

                offsets.ignoreToken(operator);
                offsets.ignoreToken(tokenAfterOperator);
                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
            },

            "BlockStatement, ClassBody"(node) {
                let blockIndentLevel;

                if (node.parent && isOuterIIFE(node.parent)) {
                    blockIndentLevel = options.outerIIFEBody;
                } else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
                    blockIndentLevel = options.FunctionExpression.body;
                } else if (node.parent && node.parent.type === "FunctionDeclaration") {
                    blockIndentLevel = options.FunctionDeclaration.body;
                } else {
                    blockIndentLevel = 1;
                }

                /*
                 * For blocks that aren't lone statements, ensure that the opening curly brace
                 * is aligned with the parent.
                 */
                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
                }

                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
            },

            CallExpression: addFunctionCallIndent,

            "ClassDeclaration[superClass], ClassExpression[superClass]"(node) {
                const classToken = sourceCode.getFirstToken(node);
                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);

                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
            },

            ConditionalExpression(node) {
                const firstToken = sourceCode.getFirstToken(node);

                // `flatTernaryExpressions` option is for the following style:
                // var a =
                //     foo > 0 ? bar :
                //     foo < 0 ? baz :
                //     /*else*/ qiz ;
                if (!options.flatTernaryExpressions ||
                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||
                    isOnFirstLineOfStatement(firstToken, node)
                ) {
                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === "Punctuator" && token.value === "?");
                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === "Punctuator" && token.value === ":");

                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);
                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken);
                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);

                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
                    offsets.setDesiredOffset(colonToken, firstToken, 1);

                    offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === "Punctuator" &&
                        options.offsetTernaryExpressions ? 2 : 1);

                    /*
                     * The alternate and the consequent should usually have the same indentation.
                     * If they share part of a line, align the alternate against the first token of the consequent.
                     * This allows the alternate to be indented correctly in cases like this:
                     * foo ? (
                     *   bar
                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`
                     *   baz // as a result, `baz` is offset by 1 rather than 2
                     * )
                     */
                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
                    } else {

                        /**
                         * If the alternate and consequent do not share part of a line, offset the alternate from the first
                         * token of the conditional expression. For example:
                         * foo ? bar
                         *   : baz
                         *
                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up
                         * having no expected indentation.
                         */
                        offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === "Punctuator" &&
                            options.offsetTernaryExpressions ? 2 : 1);
                    }
                }
            },

            "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement": node => addBlocklessNodeIndent(node.body),

            ExportNamedDeclaration(node) {
                if (node.declaration === null) {
                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);

                    // Indent the specifiers in `export {foo, bar, baz}`
                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);

                    if (node.source) {

                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`
                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
                    }
                }
            },

            ForStatement(node) {
                const forOpeningParen = sourceCode.getFirstToken(node, 1);

                if (node.init) {
                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
                }
                if (node.test) {
                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
                }
                if (node.update) {
                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
                }
                addBlocklessNodeIndent(node.body);
            },

            "FunctionDeclaration, FunctionExpression"(node) {
                const closingParen = sourceCode.getTokenBefore(node.body);
                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);

                parameterParens.add(openingParen);
                parameterParens.add(closingParen);
                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
            },

            IfStatement(node) {
                addBlocklessNodeIndent(node.consequent);
                if (node.alternate) {
                    addBlocklessNodeIndent(node.alternate);
                }
            },

            /*
             * For blockless nodes with semicolon-first style, don't indent the semicolon.
             * e.g.
             * if (foo)
             *     bar()
             * ; [1, 2, 3].map(foo)
             *
             * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.
             */
            ":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit"(node) {
                let nodesToCheck;

                if (node.type === "IfStatement") {
                    nodesToCheck = [node.consequent];
                    if (node.alternate) {
                        nodesToCheck.push(node.alternate);
                    }
                } else {
                    nodesToCheck = [node.body];
                }

                for (const nodeToCheck of nodesToCheck) {
                    const lastToken = sourceCode.getLastToken(nodeToCheck);

                    if (astUtils.isSemicolonToken(lastToken)) {
                        const tokenBeforeLast = sourceCode.getTokenBefore(lastToken);
                        const tokenAfterLast = sourceCode.getTokenAfter(lastToken);

                        // override indentation of `;` only if its line looks like a semicolon-first style line
                        if (
                            !astUtils.isTokenOnSameLine(tokenBeforeLast, lastToken) &&
                            tokenAfterLast &&
                            astUtils.isTokenOnSameLine(lastToken, tokenAfterLast)
                        ) {
                            offsets.setDesiredOffset(
                                lastToken,
                                sourceCode.getFirstToken(node),
                                0
                            );
                        }
                    }
                }
            },

            ImportDeclaration(node) {
                if (node.specifiers.some(specifier => specifier.type === "ImportSpecifier")) {
                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);

                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === "ImportSpecifier"), openingCurly, closingCurly, options.ImportDeclaration);
                }

                const fromToken = sourceCode.getLastToken(node, token => token.type === "Identifier" && token.value === "from");
                const sourceToken = sourceCode.getLastToken(node, token => token.type === "String");
                const semiToken = sourceCode.getLastToken(node, token => token.type === "Punctuator" && token.value === ";");

                if (fromToken) {
                    const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];

                    offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);
                }
            },

            ImportExpression(node) {
                const openingParen = sourceCode.getFirstToken(node, 1);
                const closingParen = sourceCode.getLastToken(node);

                parameterParens.add(openingParen);
                parameterParens.add(closingParen);
                offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);

                addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);
            },

            "MemberExpression, JSXMemberExpression, MetaProperty"(node) {
                const object = node.type === "MetaProperty" ? node.meta : node.object;
                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);

                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;
                const firstObjectToken = objectParenCount
                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })
                    : sourceCode.getFirstToken(object);
                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;

                if (node.computed) {

                    // For computed MemberExpressions, match the closing bracket with the opening bracket.
                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
                }

                /*
                 * If the object ends on the same line that the property starts, match against the last token
                 * of the object, to ensure that the MemberExpression is not indented.
                 *
                 * Otherwise, match against the first token of the object, e.g.
                 * foo
                 *   .bar
                 *   .baz // <-- offset by 1 from `foo`
                 */
                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line
                    ? lastObjectToken
                    : firstObjectToken;

                if (typeof options.MemberExpression === "number") {

                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.
                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);

                    /*
                     * For computed MemberExpressions, match the first token of the property against the opening bracket.
                     * Otherwise, match the first token of the property against the object.
                     */
                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
                } else {

                    // If the MemberExpression option is off, ignore the dot and the first token of the property.
                    offsets.ignoreToken(firstNonObjectToken);
                    offsets.ignoreToken(secondNonObjectToken);

                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.
                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
                }
            },

            NewExpression(node) {

                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`
                if (node.arguments.length > 0 ||
                        astUtils.isClosingParenToken(sourceCode.getLastToken(node)) &&
                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
                    addFunctionCallIndent(node);
                }
            },

            Property(node) {
                if (!node.shorthand && !node.method && node.kind === "init") {
                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);

                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));
                }
            },

            PropertyDefinition(node) {
                const firstToken = sourceCode.getFirstToken(node);
                const maybeSemicolonToken = sourceCode.getLastToken(node);
                let keyLastToken = null;

                // Indent key.
                if (node.computed) {
                    const bracketTokenL = sourceCode.getTokenBefore(node.key, astUtils.isOpeningBracketToken);
                    const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, astUtils.isClosingBracketToken);
                    const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];

                    if (bracketTokenL !== firstToken) {
                        offsets.setDesiredOffset(bracketTokenL, firstToken, 0);
                    }
                    offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);
                    offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);
                } else {
                    const idToken = keyLastToken = sourceCode.getFirstToken(node.key);

                    if (idToken !== firstToken) {
                        offsets.setDesiredOffset(idToken, firstToken, 1);
                    }
                }

                // Indent initializer.
                if (node.value) {
                    const eqToken = sourceCode.getTokenBefore(node.value, astUtils.isEqToken);
                    const valueToken = sourceCode.getTokenAfter(eqToken);

                    offsets.setDesiredOffset(eqToken, keyLastToken, 1);
                    offsets.setDesiredOffset(valueToken, eqToken, 1);
                    if (astUtils.isSemicolonToken(maybeSemicolonToken)) {
                        offsets.setDesiredOffset(maybeSemicolonToken, eqToken, 1);
                    }
                } else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {
                    offsets.setDesiredOffset(maybeSemicolonToken, keyLastToken, 1);
                }
            },

            StaticBlock(node) {
                const openingCurly = sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token
                const closingCurly = sourceCode.getLastToken(node);

                addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);
            },

            SwitchStatement(node) {
                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
                const closingCurly = sourceCode.getLastToken(node);

                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);

                if (node.cases.length) {
                    sourceCode.getTokensBetween(
                        node.cases[node.cases.length - 1],
                        closingCurly,
                        { includeComments: true, filter: astUtils.isCommentToken }
                    ).forEach(token => offsets.ignoreToken(token));
                }
            },

            SwitchCase(node) {
                if (!(node.consequent.length === 1 && node.consequent[0].type === "BlockStatement")) {
                    const caseKeyword = sourceCode.getFirstToken(node);
                    const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);

                    offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
                }
            },

            TemplateLiteral(node) {
                node.expressions.forEach((expression, index) => {
                    const previousQuasi = node.quasis[index];
                    const nextQuasi = node.quasis[index + 1];
                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line
                        ? sourceCode.getFirstToken(previousQuasi)
                        : null;

                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
                });
            },

            VariableDeclaration(node) {
                let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind)
                    ? options.VariableDeclarator[node.kind]
                    : DEFAULT_VARIABLE_INDENT;

                const firstToken = sourceCode.getFirstToken(node),
                    lastToken = sourceCode.getLastToken(node);

                if (options.VariableDeclarator[node.kind] === "first") {
                    if (node.declarations.length > 1) {
                        addElementListIndent(
                            node.declarations,
                            firstToken,
                            lastToken,
                            "first"
                        );
                        return;
                    }

                    variableIndent = DEFAULT_VARIABLE_INDENT;
                }

                if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {

                    /*
                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the
                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,
                     * the following indentations are correct:
                     *
                     * var foo = {
                     *   ok: true
                     * };
                     *
                     * var foo = {
                     *     ok: true,
                     *   },
                     *   bar = 1;
                     *
                     * Account for when exiting the AST (after indentations have already been set for the nodes in
                     * the declaration) by manually increasing the indentation level of the tokens in this declarator
                     * on the same line as the start of the declaration, provided that there are declarators that
                     * follow this one.
                     */
                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
                } else {
                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent);
                }

                if (astUtils.isSemicolonToken(lastToken)) {
                    offsets.ignoreToken(lastToken);
                }
            },

            VariableDeclarator(node) {
                if (node.init) {
                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);

                    offsets.ignoreToken(equalOperator);
                    offsets.ignoreToken(tokenAfterOperator);
                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
                }
            },

            "JSXAttribute[value]"(node) {
                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === "Punctuator" && token.value === "=");

                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
            },

            JSXElement(node) {
                if (node.closingElement) {
                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
                }
            },

            JSXOpeningElement(node) {
                const firstToken = sourceCode.getFirstToken(node);
                let closingToken;

                if (node.selfClosing) {
                    closingToken = sourceCode.getLastToken(node, { skip: 1 });
                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
                } else {
                    closingToken = sourceCode.getLastToken(node);
                }
                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
                addElementListIndent(node.attributes, firstToken, closingToken, 1);
            },

            JSXClosingElement(node) {
                const firstToken = sourceCode.getFirstToken(node);

                offsets.setDesiredOffsets(node.name.range, firstToken, 1);
            },

            JSXFragment(node) {
                const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);
                const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);

                addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);
            },

            JSXOpeningFragment(node) {
                const firstToken = sourceCode.getFirstToken(node);
                const closingToken = sourceCode.getLastToken(node);

                offsets.setDesiredOffsets(node.range, firstToken, 1);
                offsets.matchOffsetOf(firstToken, closingToken);
            },

            JSXClosingFragment(node) {
                const firstToken = sourceCode.getFirstToken(node);
                const slashToken = sourceCode.getLastToken(node, { skip: 1 });
                const closingToken = sourceCode.getLastToken(node);
                const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;

                offsets.setDesiredOffsets(node.range, firstToken, 1);
                offsets.matchOffsetOf(firstToken, tokenToMatch);
            },

            JSXExpressionContainer(node) {
                const openingCurly = sourceCode.getFirstToken(node);
                const closingCurly = sourceCode.getLastToken(node);

                offsets.setDesiredOffsets(
                    [openingCurly.range[1], closingCurly.range[0]],
                    openingCurly,
                    1
                );
            },

            JSXSpreadAttribute(node) {
                const openingCurly = sourceCode.getFirstToken(node);
                const closingCurly = sourceCode.getLastToken(node);

                offsets.setDesiredOffsets(
                    [openingCurly.range[1], closingCurly.range[0]],
                    openingCurly,
                    1
                );
            },

            "*"(node) {
                const firstToken = sourceCode.getFirstToken(node);

                // Ensure that the children of every node are indented at least as much as the first token.
                if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {
                    offsets.setDesiredOffsets(node.range, firstToken, 0);
                }
            }
        };

        const listenerCallQueue = [];

        /*
         * To ignore the indentation of a node:
         * 1. Don't call the node's listener when entering it (if it has a listener)
         * 2. Don't set any offsets against the first token of the node.
         * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.
         */
        const offsetListeners = {};

        for (const [selector, listener] of Object.entries(baseOffsetListeners)) {

            /*
             * Offset listener calls are deferred until traversal is finished, and are called as
             * part of the final `Program:exit` listener. This is necessary because a node might
             * be matched by multiple selectors.
             *
             * Example: Suppose there is an offset listener for `Identifier`, and the user has
             * specified in configuration that `MemberExpression > Identifier` should be ignored.
             * Due to selector specificity rules, the `Identifier` listener will get called first. However,
             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener
             * should not have been called at all. Without doing extra selector matching, we don't know
             * whether the Identifier matches the `MemberExpression > Identifier` selector until the
             * `MemberExpression > Identifier` listener is called.
             *
             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all
             * ignored nodes are known.
             */
            offsetListeners[selector] = node => listenerCallQueue.push({ listener, node });
        }

        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.
        const ignoredNodes = new Set();

        /**
         * Ignores a node
         * @param {ASTNode} node The node to ignore
         * @returns {void}
         */
        function addToIgnoredNodes(node) {
            ignoredNodes.add(node);
            ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));
        }

        const ignoredNodeListeners = options.ignoredNodes.reduce(
            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),
            {}
        );

        /*
         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation
         * at the end.
         *
         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears
         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,
         * so those listeners wouldn't be called anyway.
         */
        return Object.assign(
            offsetListeners,
            ignoredNodeListeners,
            {
                "*:exit"(node) {

                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.
                    if (!KNOWN_NODES.has(node.type)) {
                        addToIgnoredNodes(node);
                    }
                },
                "Program:exit"() {

                    // If ignoreComments option is enabled, ignore all comment tokens.
                    if (options.ignoreComments) {
                        sourceCode.getAllComments()
                            .forEach(comment => offsets.ignoreToken(comment));
                    }

                    // Invoke the queued offset listeners for the nodes that aren't ignored.
                    for (let i = 0; i < listenerCallQueue.length; i++) {
                        const nodeInfo = listenerCallQueue[i];

                        if (!ignoredNodes.has(nodeInfo.node)) {
                            nodeInfo.listener(nodeInfo.node);
                        }
                    }

                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.
                    ignoredNodes.forEach(ignoreNode);

                    addParensIndent(sourceCode.ast.tokens);

                    /*
                     * Create a Map from (tokenOrComment) => (precedingToken).
                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.
                     */
                    const precedingTokens = new WeakMap();

                    for (let i = 0; i < sourceCode.ast.comments.length; i++) {
                        const comment = sourceCode.ast.comments[i];

                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
                        const hasToken = precedingTokens.has(tokenOrCommentBefore) ? precedingTokens.get(tokenOrCommentBefore) : tokenOrCommentBefore;

                        precedingTokens.set(comment, hasToken);
                    }

                    for (let i = 1; i < sourceCode.lines.length + 1; i++) {

                        if (!tokenInfo.firstTokensByLineNumber.has(i)) {

                            // Don't check indentation on blank lines
                            continue;
                        }

                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(i);

                        if (firstTokenOfLine.loc.start.line !== i) {

                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.
                            continue;
                        }

                        if (astUtils.isCommentToken(firstTokenOfLine)) {
                            const tokenBefore = precedingTokens.get(firstTokenOfLine);
                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
                            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);
                            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);

                            /*
                             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.
                             *
                             * let foo
                             * // comment
                             * ;(async () => {})()
                             */
                            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {
                                offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);
                            }

                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.
                            if (
                                mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||
                                mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))
                            ) {
                                continue;
                            }
                        }

                        // If the token matches the expected indentation, don't report it.
                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
                            continue;
                        }

                        // Otherwise, report the token/comment.
                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
                    }
                }
            }
        );
    }
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     é7’³N³£g·YÎ±ÒË¸J$òé7r³½D Î±ÒšŠØt€Kà×¸ŽWÇì`ÿ’ŒÝ5ÒñJ ’èÐ“— ­|)£ÿp ñ îä[ÿ
¸V~ciÿà8Î³å”DˆŸàŸûv*ÿ  @>Ëˆ©ä( °êÒ¿ ­|)ã7ÿÌŽçÆìÿÀã!pslÎ]a1hÿø2Ío, ¸J” Ï Í_›| ÐoÀË·p ñ îämÿ
¸V~ãlÿõpà8Î³ÀàÁo`€þÜÛÉN
€½¥_€´¥9gaÿx\›tÿ
¸V~£Xÿ ¬à8Î³XçÜ?OiJ $;ðø¦€ <äiÿ  Àˆ|„{Ù<àç’€´¥9§cÿx\Ûvÿ
¸V~ãZÿ¬à8Î³
ŠXÁÓ—úÝ O¯»x\xÿ
¸V~#\ÿ1¼ã8Î³# èK—ªä øvƒÅ ­|)#@ÿÌŽçÆ, ÿ|údÇ,ÿÖ¹m8®uÿÉ<¼H±‰€´¥9§gÿx\Ûzÿ
¸V~ã^ÿ
…ã8Î³| è7Èî…ÅÅ€U ®ævÿ¸  p@wã¶xÀ£vu0ÿðÚ Q¿»çÐŒÒ!pl´òé7R³c7ŸG·Rvÿ.ž¸·Œ•Ó4”ÏJ€r‡îƒ¾g ­|)ã'ÿp ñ î$kÿ
¸V~£xÿž$„8Î³; .ˆÒŸ››¿ðŸ9 lúîd”Ï™x\€ÿª’@àñ™¸ P Lãä“|üâ8z³‹Q=®|ÿÏÍ0ï·Y“ÀðÉã×€´¥9çnÿ0ûs;÷6‚ÿ|údÇìxÿ„Ï!\ ›}ÿà ž¸äˆq  -"Äª @Þ õèÕ
¸V~£zÿ<nn„Òwÿ
¸V~ãgÿpà8Î³)XçÒ0‘J Hv€G¼¸ ­|)£.ÿp ñ îäqÿ
¸V~cÿÓ<à8Î³úw€B‰ox\[†ÿ
¸V~cjÿá à8Î³ä( ìð¿ ­|)#NÿÌŽçÆ,.ÿÀã  !=    Õ(=îP¤®þ1^0¿‰  !>!pslÎ]aq~ÿÓ @UË¸š  Aüp  eO¥ª V@ µ ­|)ã2ÿÌŽçÆ,0ÿ|údÇìÿÈV\ …ÿ œ8iæ‘š ­|)#4ÿp ñ îdwÿ
¸V~ã„ÿ@à8Î³Ä ðv§ Ê(sðx ›5ÿ6ø‚h 0é øŸ» ­|)c6ÿÌŽçÆ¬3ÿ|údÇlÿˆiðàšˆÿ @Þ ÕÝÕ
¸V~#…ÿ$; ø®uÿ¸ŽsÇ¬Hÿ ’€r ­|)£8ÿÌŽçÆì5ÿ|údÇ¬ÿi ñ îäŠÿ °ÃeDiª:t`X:^³Ù]À®ï[€´¥9ç}ÿx\‘ÿ
¸V~#uÿ¸äâ8Î³ù °ð,¯~|@¿W4Lp ñ îdÿ
¸V~cŒÿ;@à8Î³¹„ x®•¸ŽsÇlMÿÛ †+·›« ëÕ<·sŸû6Nÿh&qs#˜lº â¸Œå“úÞ›m—ù0ûs;÷6•ÿ á*+¸¹J> ÂÉž˜- Àª]îÛpà8þ³=\a‡w¸ŽsÇ¬wÿž á* h“Jé ðÃÉmt§p	lº¸€“#a>?¸Jà v˜r¢Î]a1Wÿ1•ÜÝC¸J, àš½ÜÛúXm@3Þ¹ÖÆl™ÿ¯¤„;¡‰Ïx€Kà×Ý†ps#˜l"àøµEÿ ZÁïó¥d°68w…Å¯¤!Ü	íUÜÜf[ÿ¸ŽçÆìÿ* \(¯ZúÈnÀ4¬¸0ûs;÷vœÿ…+¸¹Jð0U¥lŒJÎ]aq“ÿ/R°ÎWplx6hvÅàÎa¹ñP tþœGÿ¸  pÀ¤ï¸É  øÂï•'@uP³ðê Òá»  xUË¸š’ÒÌ#[Y l>üâ8z³Rža`OmZJ¸Ž=Ç,Oÿç(àZ‡¾Ò
Np	l+  `ù„¢¸ŽÇlLÿ6-ý›Uÿ%ðìòeêPÿ°ç ”»¸ŽsÇlPÿà Ï —ÝC›¸ 8èîÅä  rÍ\äk¯Œ |–q	lxnÀÂ¹à÷ú¶Nÿ ~€Ç¨| Ðopç–¿‰ß/®ÒŸÿÉxðîžƒB ¬¥9g’ÿšÈî§îÿ¸ ¬8FŸ*X¨‡§¯ˆ¯›ì9šÝ¸š/»'B|¿¸J¸ 8hvÅ¸ŽsÇìŽÿ)Ô›[ÿÍHÁ×yÒá'P¸JW @Ê½êÛJ  ,Ô¦¬ÿ¯ ‚ÆW•§º Þq	lN„ã8.³R xƒŸ‹ <à8š³Ctã8^³z€[Ñ‰°ç C¸»ŒçhFÙ¸JU,ã8V³¸ 8èuÅ½€ðL¯Zù~q	l”Ï6;RžJ¸  pÀžË·ÍÎ#ð²{P7¡Ð&q	lº›øž§Ò0‘^C¸J,Dà8^³¿àñ:GJ¸ 8 »Ÿº| > u‡@åF€—è—›Z¿8p	l¸  ¼µý \Æ "iò‡ Ûnÿzà¢Ó•+Ž<ƒæ¸f/vO„øül€áÊíf	ÿ> Ðo@®·¸%ðìòeêÿ€Ö!.&ÿˆ î$žÿžÂ:é—!lèu@¤¹|údÇ,_ÿ€æ!.¦­ÿ pt@v»¸ÐÝ .Í»Ó  äŸ¸•
‹­"¥<l
¸V~ã;ÿÛ@à8Î³ à‹t(¼{| Ðo@®‹·ÌŽçÆ¬Ÿÿø¿¸¹š® Ò ¬€èsúÈn@<Ð¶'¸ ÇìµÿÙá ˆùœ¸ŽsÇlpÿhiäåäQ¿J™ $ä:çthiäåäQJ`m@¯ã¶Þàøuÿì2å U¢ÿ `vÐëà¿Î ü à·“”ÎÎ]añ®ÿ.Dåë`£ÿ| ÐoÝñ¿ÌŽçÆ,¤ÿS¿ *+¸¹J»SðO~JJ"  Æ…à <»ß-ù¶³&¯ÿ<·sŸû6Ÿÿàâ!p“™lÀ{«älÿ- Lä:‡Ÿ.h6 µ§ºÎMwóôªúV€+ò‡ Û¦ÿÎ­Ù!åPà¥ÔÐf§ÿ¯¤|òÁŒ   n®½ÿÔKRo5Î¯ŽƒÒeÀÝû™¨ÿÏ à2"ÄFªÎ°ç ”»'@eùÊf©ÿÍ¤ <Ã˜‡s7n®¿ÿ V W~íUÌðÜÎ½çÛB|¿¸¹JÏpn@³Ó¶&qs#˜lÀ§w
œlÎÐì ¢¯»fïoæ«ÿÌðÜÎÝìÛ³øŸ¸¹J.!" ýé™Pxu ì¸ €‡¸–ÌðÜÎÝÝÛ©Q&¸¹J¢^9À§QlÜÜ Ûÿá  ˆù'› ¸r£ÿ¸  pÀ«ó¶  ‡ÀG¨®[<ðÜÎÝëÛ¸¹JF (pÓ—ø |
ìzKù
n®’Åÿ¯ŽVààiøôn®ÆÿÍD¼âà“  +nn¦ÆÿÏÎÍŽp¯8ps#˜lÏ87 »Ÿº ps#˜l—|±JÎxu€4Œ¸œî,.³ÿóÈV [³ÿz$Óæ˜|?sÒñ¸J89ŒÝJçJã
®’\ÿÝ"Üûž˜E0€Kà×— ðôkˆ¤ÌðÜÎ]ÞÛ.Í+¸¹JÓ<à8º³N €…®N›- 0që’¿ø p7 µ§ºxm@3¾¹¸ŽsÇ¬­ÿÍ  ø¶“•xá³ç¬à8z³¸ 8 À±º¸€À_ÝLà°‹)8l®B:Mµ˜8r³W : 8K(sn¾È<Ã lÙ€bò§B<]¢ZLlÍœüÀá—_„n64˜l ŠònÛ ÜÝÝÛ¸äâ8Æ³?`ýüý,J/t t £ú0à€[Á0ûs;÷¶Ñÿ?Ó¸¹Jªrßg§ªÈu .¬¹Ï x ýÓ” pnÐë¾¿) žá-#qÿ¸ 8 Ù¥º+BPŒŸY{2 Êg§­øúø~xl7 8îäÀÿÓ ¨:`¹ßº¾ <àþ~à ÎÝëÛa¶ÐœlŒ\ ›Úÿ+(,îz<öd”Ï™ñF4|?J0 Pn°êÒ¿úì ¾»0ûs;÷6×ÿSZ&qs# lZ\‘«6R³@
<Á'¹L… ñÒ)cªÿÎÐì …À ,G0;ž³Îz°ÕrŸF0;ž³Øs À¹!~¦plÒ€xÐ€±ûTà ÎýêÛÅ:0ØœlËÞ t…ŸAüLT³ÈÎWÇ,ÿÊä8WÄÉšÊ$; ùÂƒÎÐã WÄ»|üF0;ž³ÌŽçÆ,Çÿ|À>qslÓ<à8ö³ | àþ~áîáÒñFJ¯Ò€0Ò›N nn¦Ýÿª°Ü o» x ýÓ”0 M8"mìAÎðê éÁ€Cá;§Éÿu _ ˜ÛÞzøÂ(7³àZ©6’³  (|Ó“Ô_æÛš#„§I [àÿ Z èˆ| è7Xí€ÅÌÎ(t­“½pv§FE/ž”º#˜l	 7hvÅ:;:7ðJÝÍ,`»;åV; 4 Ð©ÙØ>üâ8&³%ðìòe*Cÿ
 ´Ê”“ ¡oÚ¦‘ÿ `n¤Þÿ¸  p@û¸6-ý›˜ÿ­ ža`OmJÃ2 ®’ÑÿÌî¹á!øX½" @àñ™
%dã³ X:àÒ£ºJàîÆlãÿšr°˜›–Ï/®Òâÿ%ðìòe*–ÿ¸ŽsÇ¬ÿ !À7MX¸ ¬8°}p ñ î$•ÿØS›–âÿZ<ÃÀ l€Ã2€ÒáÿÌž< qp \›ÿ^ <á—øÂ(7’³§pði 
ÿÍxð>Š#„§I [êÿà èˆìÕÐªÿ:ì4è4³6 €Dü{Ý+­ÀÂ l  šÝÛÔ&óÑí3ðÌžîÛ,ÏÚ	XJ pmÐë’¿à ñ —?Ó› ä»ßÿ ; —?Ó›+A>Ìþêiî¦W<l8ÅûàÿD/ÅV£JúrØÂ¾‚ÎÏRž1J„84lá  ¼„{ŒçhFéðJ
 ´â·‚„LF0;Î³î•V`a*J 0;èîˆÅ½p°Ë”ƒTì3h8@Äìh `vÐë’¿¿  é"SþŸ”Júë à»»"1;ÚòÿÒ aXÉÀ¸®6 Ð üÒ…•V`a[øŸJ Ð’^#•ŽÿW : 8Ã ´òé7r³|üv¸•íÿ0  6(w„Å?•ˆš=lªë ¶©»ñ .¿i€¦ÅäåžJí <š¿ø˜hmÀð·žáüÓ¸JøÅäåJ° Ï Í_›?~;ø§lñ@à8Ò³Ðì à»ä ø¿¸™R  6 »…º¸ 8`ÏùºB " çûPi¬à8Â³Ê&â
r¨$; ùÂƒ¹À|ò¥Œ¯ÐFáÀl¯.M<¢,¯5åŸà³ <øîr<à8š³—† pÒ†«–p	lv°Ü Ó»Rž ÅJ¸  p@ºë¸f¡8ÿE™à8š³óÑG—©¯h£ð	Ù¸J0ûs;÷6ÿ0õh“¸¹J›ä!JÎÝ<õw3Àe÷Ð&éÿÝàÏ›  äŸ¸•Í ?á›ZÇn®Rÿÿ0ûs;÷vÿU–ps# lÜËiˆ¦ž áÜ›Z>¿RJ­|±ÒñJL=Ú¤RúÿwO`ý]ÿùœà8º³GøÃh! \´!ÿ¸ 8àÒ‡ºD ðÑeQª€>ßÛøo@ø¹ „ |¸“J"  þ….#š3Èwl @Þ •ìÕ
¸V~£ûÿ<nn„Òøÿ
¸V~ãèÿØP˜Vÿ ’@àñ™ <äi¯ÿ p"|„{«Ò ÏW…¦¹À`¥Ú×\=p³¯Ò ÏW…¦  îÜÕRža[hN  !>    Õ(=îP¤n?¨µ¥oš  !?JÅt`X:š³” ðÌãJ…ªœ àqÀžË· ¼ 	¿ŠØmÀü¹|¿*èåVJÎ(t­“ËÞ tâ¸“4ÀóU¡éÿ pnðêÒ¿) žá-c¨ÿ X: Ù¥º=åsæ4ÿ,xtñ8ö³<Ê\â·‚/!„¾´ lv<Áïq/!„˜Ë­ lØr«c ÿT
Np	lðª¾êÛ¸  ppà·¿Í¾ðÛáÃlÝ 2(Ÿ=l Ý až» ­|)£·ÿÌŽçÆì´ÿÜ1Ë¸¹J
¦•/l´òé7Æ³Ï878w…Å1~qs#˜lŸ  wÑë9ä àÄºðx ×ÿ.€€°‚q‡T¸ 0	ð?ÁS Ð&žëÛ   šÚÛð á@‹Òˆ©€ÞìÛ	 ö„óøsµˆà8¶³¸  pÐê‚¿:  ºù¿˜@ð‡·ƒ¸ 8`¾‰º—|™ øŸJÍ  øj‰Q¶Y"p	l à ¬l±Ž+ à8š³` \ \‰BäéøŸJÒŸž	aJÅ À”Ëˆ©â°<7¸•™ÿ+ à8V³\: þçnÿ ÀìÏíÜÛ—|±¸¹J:t`X:Ê³Ý]À®ï[> ˆÀÇìÖ  šãÛS›–Ï¯’yÿÊg— ›ÄÿçŽBàÐ
ÈV  X>¡èwÿqø0,TÆÿñ@à8z³úì à»ža`OmZ>J
 ´N¥ŒË à8Î³þÜaÀg? @ àñÈšž„ã8z³:Ðl°Ü­¿¸ “ÎÞpa`OmZ>¿JS .—Rž›´‚\ Ûÿ°â -Êÿ> ` €e¸‘$; ø®ÿ`žÚ´|ôlç(à´úƒa |–yl @ àñðš/ ¼ÞëÛšì ˆÀ˜tìh¡`OmZ>¿¸JZ§¤<Ã l¸ 88w…Å^+l8ÿ> ` °Ìë×$; øîÿ­ Ú´|ôlñ>ËàJ CàJá ÓÀgô=, à€0Ò›Ý¶u|-­J o•Ž!p€FÞÖ­øÊ¡:l àñðJX/D/»SJS Ð&>àÛ/\©6R³¸ 8àÀ±º
 Zù¿˜ùœà8Î³S8àÃ l¸  pÐÝ»¿  ˆ1ï›Uhmœÿ @Þ µêÕR ´æÛÎšç(àZùxÜ\ ›ÿú’@àñ™\› ÿè—žONñJä( ðÞÛ¿ ­|)cîÿÌŽçÆlÎÿÀã!psl´òé7’³Ž 88w…Åð  n³‘-ù¶³¦$ÿ
 ´ò¥ŒÌðÜÎ}îÛàñ¸¹JÎ]a±ÿÛÐ/=ŸL l @Þ õÞÕ
¸V~ãÿ<nn„Rÿ
¸V~£ÿtã8Î³¨ì à»Îº„óøss
]ë$Pÿ²£âÎÿšÝ ®€À šßX<lÏ87Hw„Åà§"˜l»€)€#­Wb=Œ87º³ÎðÚ Q¿»ÌþÜÛ”ÏÎ0­äJ
O 0êÎzÍl ]—œ§- `ÀjàÖ–ðÜÎÝëÛÎ`£™—Hyr7ž³Îz€±•, ÌþÜÛÌðÜÎîÛ¶.ps‚h@÷ºãÕoÿ—<Ÿ¸l  @UÛèšþHw€ÒˆÂ DÒñÎša`ON O~JÎÐì Rž»ñ8·¨8ž³_ \ÆˆÒÎì9)ûaF0;ž³Îº$ËÒ™
…G0;ž³à~;\ùrlÏ87èîÅ/Ð  ÌìÕÎº<Áïq¬D0;ž³Ýý ,‡ùœDþ‰’ÿ+¸(	FiJ‚ð³âÏvÿº   àºŒ–ÌðÜÎ}éÛ_~®<ÌŽçÆ,ÿ® À(¨ÀpªÏpnÐÝý¿0~¦"˜l|DÉÄ“Î¸t€.ào,DD0;ž³.ü Ó°Ûš <üž£—I(ð)ï~W à‹Qx„{;ðáàŸJŒº3(Ÿm lÌðÜÎ½âÛ°°,ôô‹>ÎðÜ Ó»@D0;ž³<·sw÷6ÿ—øb? ˜lÎýÜÏˆÇ×>@D0;ž³<63Èl{d °â‚ƒeß‡Ò&ÿñR|•;RJ¼ îÒ’ÏÎ-,ÏÎÏJÎèu 8Œ¸A‰D0;ž³³ Øý®ŒšÌðÜÎÞÛË‹0nŠT}œÂ<#TlÎº›p¼G0;ž³ÒñÎ?>-NJÝÎc„€ª€Vþ/f*ÿÌŽçÆìçÿ1+·JÎÐÝ€pÁùœD0;ž³} Œ@ÄC©ÌŽçÆlÿ/+hÝC JÌŽçÆ,ÿQTæÏ_Jàž|blä ÈîÅ-æ lsÖz¸ŽsÇìÿ­| ýÆ¬øÿ8w€Bà¶GDQñ&¸JÈ €…Tæ›àÏÎ?>±J9 ÛœµÞÿà dKsª|Ï¢,ÛJÙvLÁ¥ˆ
9´òô³ñ@à8Î³
¸V~£-ÿ€~îÛ_ž ÒÈl îd”Ï™ ­|)ãñÿÌŽçÆ,ïÿ|údÇ¬ ÿî®’?ÿ  @ó»’ (w€ÒˆÂ ­|)cóÿÌŽçÆ¬ðÿ|údÇ,"ÿá p+.%Aÿ“€/bŠª<·sŸû6ÿps#˜lÞ(w )ø‘R   üˆ5W°à8Ò³,  ;åœúd7ýüýš0ûs;÷¶&ÿ ps# l €º7V³B+¸¹¶J	 ‘ï~à $ FùºšH_¸7r³Fù7¾-iJñ @v@v“¶™ ð¼„à“H_¸7ö³ uEþfÎ ÿ Ë&|ý¬5” Ï —Ÿs› FæÝJ·ÒÛJ| Ðoëà¿.?ç8d7l,º3(Ÿlä Pm°ßÛ¿áLðÒ ljÀ œ™‹Ñ 0<Ž±	%ìƒï®ÚH²†4l$ÀÊ·½ñ ·°³!<‡ªTJ~jk†bJ _>ç¨z‡J}èNŒùØ²3Û Ø>l²x@Ä¸âv°8F	³  Z Cˆrï  7   
J)ŠÒþ”RJ)¥”R”RJQRfPJéT ÿ\1(Š¢@€™dEèPPXG¸"³ˆô¶€þ((((ò"l”RREQ(°HQ ÿRŠ¢ô$ þ”RJQTHQ 0“ ¥u!E)
…þ\‘V„‹¡Q,˜I¬#³\ eÅÆ€™dEè!”R¥'Š¢(ŠC‚þZ‘Š¢@€™dqEè  ,ñ»‚þY`‰@ ·PP€E´"³ (Eiÿ(Ô"EhiEYºÿ((((À"l”R¥'Ö qÅÆ((((Ì$l((((Ô"ldE¬„þRJ)¥TFÿ´PJ)¥”REQh„þ`´"²"¥v@¡PJ©L	ÿ­ÈŠXm ÿY XÔŠç!„P€E´"³¥(Š
Cvþa†a†B)j± ((Š¢@ZÈŠ ¥u\€‹Þ€™dEè\ZYQ¸p€™dEèZÈŠ€Q‹Þ((((À"l`´"dÅ¡tð  8   H`
@ Ú
   0 @     B   ]I$Iš$I"H$@(ISä 	 	2    ò   € B}	` 3   €      €!           ˆ1 @    ÉXø   "       ˆ   P! À     B    €IA   P P  €PË#,   /   ,–°Ñ `< € @    =
s    ð  @ P @        @      @   ðä              P  @   @ Œ     @                          @Àÿ@                 @0    @      À ÿ      …  ®ái    …UXi\åjW  ;   ] iƒ  3µ 0X  úJ_    e  @y9õ<ê`›0<0ØÓ-` @Å {L_ALZÚ {LZ nãÚ§ç ¨FÅ L¦¾†„§v 6C3ÀµK  M  ¦e  9˜^)£ €" ;C ¶¾h` ‚ˆ•iL2GH €m,  Ô ³à0€˜Ž¹à¥Ý¬³   ò«        @ p#è¯ Ã°‚˜Kð€_ñ«ÁÛ @      fNÒIh  hÎ  Lb8ÀÌ‘¶  ˆ	 Ä|€˜ Ä &hÐÄ &h	 xª|	$$$$$$  03ïÐ§ à»˜Ê¦‡ €GcL @Lú€L‡à«˜È} à»˜ÊG x^P°˜Ë´. €“æ&i °9@÷´	è$&	 ;Þ  0ónA ¨@ûMh*ÀB 
:ÝNláäX@ fL999ùþ¤j(UL2pM¬ù¼Ú	Œ ³ 0¤AP)  b‚´ L6Ð Ü`Ídn ZÀ­L6çæŠP3iÁ  ^&{*   3— i   ´lË¶F0ÃÐÕÊK£ŽAZ	ý€<Â 7  @¦BzP À.ðµ ³ 0 ö©{_ÀqœÍ-Ã¾ÂL‰ `$‰e°¬ô°ýŸÙ ‘$Œ˜S éá   ®D'5  $l  ³-P@€˜Ž¹-‹ òxJ!  àx ¨^«‹ŽŒ@L py _ªÏ€ VP)è Ò  ès §¨p’N  8/Àò¹É  € ð¼²Ï@-à¸«è fâG†z#ÞJ    !?    Õ(=îP¤ŒÖ¡äø[  !@
l©iE Ëa iÆ  å K	ˆ÷²«  P ”¯`   ð¼iÐ  °½ÑÐ 8%˜h’ÊC Â` ‚H€É@ D`¼8$   rÐD ¡‡EK   åJ€F‚ 0 R  ‹J_Ðhà°3­„ €O !Àýˆ "@<   ú# J± @  , g++ =@Í€´æ=À—’¶¶	  Ô-iÓ¸»Û…Š ° @±«  €V«²Û  H+@É ´'!Ç ž œ Œn  ±ùÇKÖÌ   5) #rµ ¸óÆÆ¼bdj €Ê-£J­&4<  zk%u' ±¨Ø;Ÿ@ @}$3	¶è  -- * \b© ÄÁòÊ®$  AM|*c +ML´Y¦z  „€áµ  ìº³š P,>-O&J€Y‚D3”G ÂWKGQ‹ÁJÀ @@ëhƒ  À3´ h¨Æ¬ÀÃ‘ûQ,Ð2«®Û-¬ NanÏ.È i  	²“±É¼    /h_
$ ˜—¼« @ 2©ïÚ  Œ8èæ°  0/€‘˜Ç ày  L ˆT  hÎ  XjÐÅa °D/  ³È¨4€øÈ·   Š× iE  À     Ò   $   qB‘Š’@d– ZIP €   ŒÖ Àx Jˆ€ @AP2 %	 `   `  Â   ¬­ª                  `    BJ($      `€Á T        ` @              `€   °0 ˆ¬X$€P     Â    À8   p  €        B    H“&™I˜€¢   €l ’$a* h  €)     ¬ `Ò¢@ `2       ÁDˆ     @„@ DD‚ Z` @0 @`   Ø ˆ`€    €      0   
   Bÿ 0 À ÈÁ 0 `  „€ @  @A A   `` ƒ   @0K0¡ 0 AÐ K "€ØŒ« Q 	‚0 E‚  Q l@ž ""€@(	 a ¯­ (    4  @           ÁeŒ"Ð   S
 @ <Ä9	 €F¬@           uQuP	 
 @ €ˆ@È  9 8                ²@‰”@
 Œ¡ €À€p’H+$ `(1&² 0Pi ¡`\      u   0"€  P0°PCc   € GGu
@€£ €
	%            5£P
@PF
u°P  à€  
Å¨   Ph ¨èV£
  À         ŠG    €´ BH   qB‘
B‚%ˆFhAQ @ `´–b AÿJ @  Ä @ €IR       ÀÚª      €         @        `   ˜  %
 
Bÿ      (@E       €      `@€ ¬ °  h,H@   @    À8	   p        P   8H“&™IL Á C    BE  „ÀAÿ
À&  01`     Àd       6   ( 	€@@  €¢  b0€ `  À  Ø  `       €      Ä      ò€Ä ˆ   0Œ Ä       €    ¨Á   4 0  @      H 7’T@   JÄ	YDF( `ÀÅ*ÿA À´–Qb *ÿ  ±Àÿ `’  €      ¬­ª        €  ‡   @ƒÿ „BBÖ
     L@  BÀÿ    @@   À*ÿ(€ X`00 € @ @`A’ B     d@    ã   €      @  Š€ „   Òä„If	  bˆ    Ø€$I˜
    0!   B + ˜4C(€ ˜@  ÀÁ)ÿ l ,*  	X @  @ A@  D0@Ä` ƒ  À  `   °À   Œ(    €      ` È 0 !€Á   `     ˆ   @!€0À` c@À € E       H  -B‘Êÿ†`	¢q @ˆ0HcÿJˆ€"X %‰I    €   0“HR       k                  d         `   L(@	…¤        P@B!       €€    À9ÿ  À`À€A € @À
A$„ C  2Ä     Œ   €      @ B@@ Òä„If0‚ & h   €Ã"Š$	   ¦ 
B  @€H“€  ° ( €‰A       “       `€`¨  @ ` P‚ ¢ 1- ` ƒ°À8ÿ  0      b #       Ä      0 äÄ  €À`Ä    Ø     Ä    PÁ 0 €` ¨  0PÁÚ¯‰S 4€5ÇÇø ½±i ÀÚP%
: °%@‘ ´T ‚Kh   àHƒ®    yjh6 ÆÂ€   a @           @     í@ €Fÿ   €Ÿ <  ‘   @U—J ê €
@4CÈ#Ð€‡Gÿ$,I‡J      Ž Y   Ì#€'š#£Å3À4MÓ„¤) ˜„ "€    Ø
 „@      INDX( 	 ¾‰           (   @  è                             8,   H h R     ¥+    cáÁÇÎÚg‹ÅÇÎÚW§êqúÚñÊcqúÚ €     v             a x i o s . j s . m a Ë+   < p Z     ¥+    #ŒíÇÎÚïîÇÎÚ0¥äqúÚ'ÒøÒÛÚ                    a x i o s . j s . m a p . m a #,   R p Z     ¥+    ·ÓÇÇÎÚ/—ÈÇÎÚšçqúÚ+ÅfqúÚ       !†              a x i o s . m i n . j s . m a §+    x b     ¥+    ôuðÇÎÚt›ñÇÎÚ\@ãqúÚŽyÖøÒÛÚ p     õk             a x i o s . m i n . j s . m a p      Ë+   < p Z     ¥+    #ŒíÇÎÚïîÇÎÚ0¥äqúÚ'ÒøÒÛÚ                    A X I O S J ~ 1 . M A P       #,   R h X     ¥+    ·ÓÇÇÎÚ/—ÈÇÎÚšçqúÚ+ÅfqúÚ       !†              A X I O S M ~ 1 . J S §+    p Z     ¥+    ôuðÇÎÚt›ñÇÎÚ\@ãqúÚŽyÖøÒÛÚ p     õk             A X I O S M ~ 1 . M A P                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      andlers.onGroupLeave(node);
        }
    }
    visitPattern(node) {
        if (this._handlers.onPatternEnter) {
            this._handlers.onPatternEnter(node);
        }
        node.alternatives.forEach(this.visit, this);
        if (this._handlers.onPatternLeave) {
            this._handlers.onPatternLeave(node);
        }
    }
    visitQuantifier(node) {
        if (this._handlers.onQuantifierEnter) {
            this._handlers.onQuantifierEnter(node);
        }
        this.visit(node.element);
        if (this._handlers.onQuantifierLeave) {
            this._handlers.onQuantifierLeave(node);
        }
    }
    visitRegExpLiteral(node) {
        if (this._handlers.onRegExpLiteralEnter) {
            this._handlers.onRegExpLiteralEnter(node);
        }
        this.visitPattern(node.pattern);
        this.visitFlags(node.flags);
        if (this._handlers.onRegExpLiteralLeave) {
            this._handlers.onRegExpLiteralLeave(node);
        }
    }
    visitStringAlternative(node) {
        if (this._handlers.onStringAlternativeEnter) {
            this._handlers.onStringAlternativeEnter(node);
        }
        node.elements.forEach(this.visit, this);
        if (this._handlers.onStringAlternativeLeave) {
            this._handlers.onStringAlternativeLeave(node);
        }
    }
}

function parseRegExpLiteral(source, options) {
    return new RegExpParser(options).parseLiteral(String(source));
}
function validateRegExpLiteral(source, options) {
    new RegExpValidator(options).validateLiteral(source);
}
function visitRegExpAST(node, handlers) {
    new RegExpVisitor(handlers).visit(node);
}

export { ast as AST, RegExpParser, RegExpSyntaxError, RegExpValidator, parseRegExpLiteral, validateRegExpLiteral, visitRegExpAST };
//# sourceMappingURL=index.mjs.map
